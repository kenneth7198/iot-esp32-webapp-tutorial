<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ¨ğŸµ Audiovisual Multiplayer Art</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000;
      overflow: hidden;
      color: white;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .title {
      font-size: 18px;
      letter-spacing: 3px;
      color: #fff;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .status {
      display: flex;
      gap: 15px;
      align-items: center;
      font-size: 11px;
    }

    .connection-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ff4444;
      box-shadow: 0 0 10px currentColor;
    }

    .connection-dot.connected {
      background: #00ff88;
    }

    .players-panel {
      position: fixed;
      top: 80px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      z-index: 100;
      min-width: 250px;
      max-height: 70vh;
      overflow-y: auto;
      backdrop-filter: blur(10px);
    }

    .panel-title {
      font-size: 12px;
      color: #00ff88;
      margin-bottom: 15px;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .player-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      margin: 5px 0;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 5px;
      border-left: 3px solid transparent;
      transition: all 0.3s;
      font-size: 11px;
    }

    .player-item.active {
      background: rgba(255, 255, 255, 0.1);
      border-left-color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
    }

    .player-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .player-name {
      flex: 1;
      font-weight: bold;
    }

    .join-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      padding: 40px;
      border-radius: 15px;
      border: 2px solid #00ff88;
      box-shadow: 0 0 50px rgba(0, 255, 136, 0.5);
      text-align: center;
      z-index: 200;
      min-width: 400px;
    }

    .join-panel.hidden {
      display: none;
    }

    .join-panel h2 {
      margin-bottom: 10px;
      color: #00ff88;
      font-size: 28px;
      letter-spacing: 3px;
    }

    .join-panel p {
      margin-bottom: 25px;
      color: #888;
      font-size: 12px;
    }

    .join-panel input {
      padding: 15px 20px;
      border: 2px solid rgba(0, 255, 136, 0.3);
      border-radius: 8px;
      font-size: 14px;
      width: 100%;
      margin-bottom: 20px;
      background: rgba(255, 255, 255, 0.05);
      color: white;
    }

    .join-panel button {
      background: #00ff88;
      color: #000;
      border: none;
      padding: 15px 40px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      letter-spacing: 2px;
    }

    .mode-info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      z-index: 100;
      backdrop-filter: blur(10px);
      min-width: 200px;
    }

    .mode-info .label {
      font-size: 10px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .mode-info .value {
      font-size: 16px;
      color: #00ff88;
      margin-top: 5px;
      font-weight: bold;
    }
    
    .control-btn {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid #00ff88;
      padding: 8px 15px;
      border-radius: 5px;
      color: #00ff88;
      cursor: pointer;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .control-btn:hover {
      background: #00ff88;
      color: #000;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }
    
    .control-btn:active {
      transform: scale(0.95);
    }
    
    .help-info {
      position: fixed;
      bottom: 20px;
      right: 280px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      z-index: 100;
      backdrop-filter: blur(10px);
      font-size: 10px;
      color: #888;
    }
    
    .help-info kbd {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      color: #00ff88;
      font-family: 'Courier New', monospace;
      margin: 0 3px;
    }
  </style>
</head>
<body>
  <!-- Join Panel -->
  <div class="join-panel" id="joinPanel">
    <h2>ğŸ¨ğŸµ AUDIOVISUAL</h2>
    <p>å¤šäººäº’å‹•è²éŸ³è¦–è¦ºè—è¡“</p>
    <p style="font-size: 12px; color: #00ff88; margin: 10px 0;">ğŸ’¡ æç¤º:é»æ“Šç•«é¢ä»»ä½•åœ°æ–¹å³å¯è½åˆ°é‹¼ç´è²éŸ³</p>
    <button id="testSoundBtn" style="margin: 10px 0; padding: 10px 20px; background: #00ff88; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">ğŸ”Š æ¸¬è©¦è²éŸ³</button>
    <input type="text" id="deviceIdInput" placeholder="è¼¸å…¥ä½ çš„è¨­å‚™ ID" />
    <button id="joinBtn">é–‹å§‹é«”é©—</button>
  </div>

  <!-- Header -->
  <div class="header">
    <div class="title">ğŸ¨ğŸµ AUDIOVISUAL MULTIPLAYER ART</div>
    <div class="status">
      <div class="connection-dot" id="connectionDot"></div>
      <span id="connectionText">é€£æ¥ä¸­...</span>
    </div>
  </div>

  <!-- Players Panel -->
  <div class="players-panel">
    <div class="panel-title">ğŸ‘¥ Players (<span id="playerCount">0</span>)</div>
    <div id="playersList"></div>
  </div>

  <!-- Mode Info -->
  <div class="mode-info">
    <div class="label">Current Mode</div>
    <div class="value" id="currentMode">Flow Field</div>
    <div style="margin-top: 10px;">
      <button class="control-btn" id="nextModeBtn" style="width: 100%; padding: 8px; background: rgba(0, 255, 136, 0.2); border: 1px solid #00ff88; border-radius: 5px; color: #00ff88; cursor: pointer;">
        Next Mode
      </button>
    </div>
  </div>
  
  <!-- Help Info -->
  <div class="help-info">
    <div><kbd>SPACE</kbd> åˆ‡æ›æ¨¡å¼</div>
    <div><kbd>S</kbd> å„²å­˜æˆªåœ–</div>
    <div><kbd>CLICK</kbd> è§¸ç™¼éŸ³æ•ˆ</div>
  </div>

  <!-- Canvas Container -->
  <div id="canvas-container"></div>

  <script>
    // ========== è¨­å®š ==========
    const WS_URL = 'ws://192.168.100.200:8080';
    let myDeviceId = '';
    let ws = null;

    // ========== ç©å®¶ç®¡ç† ==========
    const players = new Map();
    const playerColors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
      '#FFB6C1', '#DDA0DD', '#F0E68C', '#B0C4DE', '#FFE4B5',
      '#FF69B4', '#87CEEB', '#FFA500', '#32CD32', '#9370DB'
    ];
    let colorIndex = 0;

    // ========== éŸ³è¨Šè¨­å®š ==========
    let audioContext;
    let masterGain;
    let synths = new Map(); // deviceId -> synth objects

    // ========== p5.js å…¨åŸŸè®Šæ•¸ ==========
    let particles = [];
    let currentMode = '3dheart';
    let modes = ['3dheart', 'symmetry', 'neurons', 'shader']; // ç§»é™¤ 'particles'
    let modeIndex = 0;
    let time = 0;
    let rotationSpeed = 0.01;
    let seed;
    let rez = 0;
    let palette = [];
    let mySize;
    
    // ç¥ç¶“ç¶²è·¯è®Šæ•¸
    let neurons = [];
    let connections = [];
    let numNeurons = 100;
    
    // Shader è®Šæ•¸
    let theShader;
    let shaderGraphics;
    
    // Particles çˆ†ç‚¸æ•ˆæœè®Šæ•¸
    let parNum = 1000;
    let color_vision;

    // ========== p5.js Setup ==========
    function setup() {
      mySize = min(windowWidth, windowHeight) * 0.9;
      createCanvas(windowWidth, windowHeight, WEBGL);
      colorMode(HSB, 360, 100, 100, 100);
      
      // è¨­å®šéš¨æ©Ÿç¨®å­
      seed = Math.random() * Math.pow(Math.pow(int(TWO_PI), 3), 2);
      randomSeed(seed);
      
      // åˆå§‹åŒ–èª¿è‰²ç›¤
      const colorSchemes = [
        ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
        ['#FFB6C1', '#DDA0DD', '#F0E68C', '#B0C4DE', '#FFE4B5'],
        ['#FF69B4', '#87CEEB', '#FFA500', '#32CD32', '#9370DB']
      ];
      palette = random(colorSchemes);
      
      // åˆå§‹åŒ–éŸ³è¨Š
      initAudio();
      
      // è¨­å®š 3D é€è¦–
      perspective(0.5, width / height, 5, 10000);
      
      // åˆå§‹åŒ–ç¥ç¶“ç¶²è·¯
      initNeurons();
      
      // åˆå§‹åŒ– Shader
      initShader();
      
      // åˆå§‹åŒ–ç²’å­çˆ†ç‚¸æ•ˆæœ
      initParticles();
      
      frameRate(50);
      time = rez = 0;
    }
    
    // ========== åˆå§‹åŒ– Shader (SamuelYAN Style) ==========
    function initShader() {
      // Vertex shader - æ¨™æº–é ‚é»è‘—è‰²å™¨
      const vert = `
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;
        
        void main() {
          vTexCoord = aTexCoord;
          vec4 positionVec4 = vec4(aPosition, 1.0);
          positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
          gl_Position = positionVec4;
        }
      `;
      
      // Fragment shader - SamuelYAN é¢¨æ ¼çš„ç”Ÿæˆè—è¡“
      const frag = `
        precision highp float;
        
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_frame;
        uniform vec2 u_mouse;
        
        varying vec2 vTexCoord;
        
        // é›œè¨Šå‡½æ•¸
        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        
        // 2D æ—‹è½‰çŸ©é™£
        mat2 rotate2d(float angle) {
          return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        }
        
        // åˆ†å½¢å¸ƒæœ—é‹å‹• (FBM)
        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        
        float fbm(vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          float frequency = 0.0;
          for (int i = 0; i < 6; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }
        
        void main() {
          vec2 st = vTexCoord;
          st.y = 1.0 - st.y; // ç¿»è½‰ Y è»¸
          
          // æ­£è¦åŒ–åº§æ¨™
          vec2 uv = st * 2.0 - 1.0;
          uv.x *= u_resolution.x / u_resolution.y;
          
          // æ™‚é–“è®Šæ•¸
          float t = u_time * 0.3;
          
          // æ»‘é¼ äº’å‹•
          vec2 mouse = u_mouse * 0.1;
          
          // å‰µå»ºå¤šå±¤æ—‹è½‰å’Œæ‰­æ›²æ•ˆæœ
          vec2 p = uv;
          p = rotate2d(t * 0.1) * p;
          
          // æ·»åŠ æ»‘é¼ å½±éŸ¿
          float mouseInfluence = length(uv - mouse) * 2.0;
          p += mouse * 0.3;
          
          // å¤šå±¤æ¬¡çš„ FBM å™ªè²
          float n1 = fbm(p * 3.0 + t);
          float n2 = fbm(p * 5.0 - t * 0.5 + n1);
          float n3 = fbm(p * 7.0 + t * 0.3 + n2);
          
          // å‰µå»ºæµé«”èˆ¬çš„åœ–æ¡ˆ
          float pattern = sin(p.x * 10.0 + n1 * 5.0 + t) * 
                         cos(p.y * 10.0 + n2 * 5.0 - t) * 
                         sin(length(p) * 5.0 + n3 * 3.0);
          
          // æ·»åŠ èºæ—‹æ•ˆæœ
          float angle = atan(p.y, p.x);
          float radius = length(p);
          float spiral = sin(angle * 8.0 + radius * 10.0 - t * 2.0 + n1 * 3.0);
          
          // çµ„åˆæ•ˆæœ
          float combined = (pattern + spiral) * 0.5;
          combined = smoothstep(-0.5, 0.5, combined);
          
          // æ·»åŠ è„ˆè¡æ•ˆæœ
          float pulse = sin(t * 2.0) * 0.5 + 0.5;
          combined += pulse * 0.2 * sin(radius * 20.0 - t * 3.0);
          
          // é¡è‰²æ˜ å°„ - å„ªé›…çš„æ¼¸è®Šé…è‰²æ–¹æ¡ˆ
          vec3 color1 = vec3(0.4, 0.2, 0.8);  // æ·±ç´«è‰²
          vec3 color2 = vec3(0.2, 0.6, 1.0);  // å¤©è—è‰²
          vec3 color3 = vec3(1.0, 0.4, 0.6);  // çŠç‘šç²‰
          vec3 color4 = vec3(0.3, 0.8, 0.9);  // é’ç¶ è‰²
          
          // æ ¹æ“šä¸åŒçš„å™ªè²å€¼æ··åˆé¡è‰²
          vec3 finalColor = mix(color1, color2, smoothstep(0.0, 1.0, n1));
          finalColor = mix(finalColor, color3, smoothstep(0.3, 0.7, n2));
          finalColor = mix(finalColor, color4, smoothstep(0.4, 0.6, combined));
          
          // æ·»åŠ æŸ”å’Œçš„ç™¼å…‰æ•ˆæœ
          float glow = 1.0 - length(uv) * 0.4;
          glow = pow(glow, 2.0);
          finalColor += vec3(0.15, 0.1, 0.2) * glow;
          
          // æ·»åŠ é‚Šç·£æšˆå½±
          float vignette = 1.0 - length(uv) * 0.6;
          vignette = smoothstep(0.0, 1.0, vignette);
          finalColor *= vignette;
          
          // æ•´é«”äº®åº¦èª¿æ•´
          finalColor = pow(finalColor, vec3(1.2)); // ç¨å¾®æäº®
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `;
      
      // å‰µå»º shader
      theShader = createShader(vert, frag);
    }
    
    // ========== åˆå§‹åŒ–ç¥ç¶“ç¶²è·¯ ==========
    function initNeurons() {
      neurons = [];
      connections = [];
      
      // å‰µå»ºåˆå§‹ç¥ç¶“å…ƒ
      for (let i = 0; i < numNeurons; i++) {
        neurons.push(new Neuron(random(-width/2, width/2), random(-height/2, height/2)));
      }
      
      // å‰µå»ºåˆå§‹é€£æ¥
      for (let i = 0; i < numNeurons; i++) {
        let neuron = neurons[i];
        for (let j = 0; j < numNeurons; j++) {
          if (i !== j && random() < 0.05) {
            connections.push(new Synapse(neuron, neurons[j]));
          }
        }
      }
    }

    // ========== åˆå§‹åŒ–ç²’å­ç…™ç«æ•ˆæœ ==========
    function initParticles() {
      particles = [];
      seed = Math.random() * 1000;
      randomSeed(seed);
      color_vision = random([1, 2, 3, 4, 5]);
      
      // æ¸›å°‘åˆå§‹ç²’å­æ•¸é‡,è®“ç…™ç«æ›´æ¸…æ™°
      let initialCount = 15; // å¾ 1000 æ¸›å°‘åˆ° 15
      for (let i = 0; i < initialCount; i++) {
        particles.push(new Particle(
          random(width * 0.3, width * 0.7),
          height - 50
        ));
      }
    }

    // ========== p5.js Draw ==========
    function draw() {
      background(0, 0, 0, 10);
      time += 0.01;
      
      switch(currentMode) {
        case '3dheart':
          draw3DHeartPattern();
          break;
        case 'symmetry':
          drawSymmetryPattern();
          break;
        case 'neurons':
          drawNeuronsPattern();
          break;
        case 'shader':
          drawShaderPattern();
          break;
      }
    }
    
    // ========== è¦–è¦ºæ¨¡å¼ 3: Neural Network ==========
    function drawNeuronsPattern() {
      // ç¥ç¶“ç¶²è·¯ä½¿ç”¨ 2D æ¨¡å¼
      push();
      
      // ç¹ªè£½é€£æ¥
      for (let synapse of connections) {
        synapse.display();
      }
      
      // æ›´æ–°å’Œç¹ªè£½ç¥ç¶“å…ƒ
      for (let neuron of neurons) {
        neuron.update();
        neuron.display();
      }
      
      // éš¨æ©Ÿç™¼ç«
      for (let neuron of neurons) {
        if (random() < 0.01) {
          neuron.fire();
        }
      }
      
      pop();
    }
    
    // ========== Neuron Class (ç¥ç¶“å…ƒ) ==========
    class Neuron {
      constructor(x, y) {
        this.position = createVector(x, y);
        this.fireRate = 0;  // ç™¼ç«å¼·åº¦
        this.baseColor = color(random(palette));
        this.hueValue = hue(this.baseColor);
      }

      // ç™¼ç«
      fire() {
        this.fireRate = 255; // æœ€å¤§å¼·åº¦ç™¼ç«
        setTimeout(() => {
          this.fireRate = 0; // ç™¼ç«å¾Œæ¢å¾©
        }, 100);
      }

      update() {
        // ç™¼ç«ä¸­é€šéçªè§¸å‚³é€ä¿¡è™Ÿ
        if (this.fireRate > 0) {
          for (let synapse of connections) {
            if (synapse.inputNeuron === this) {
              synapse.transmit();
            }
          }
        }
      }

      // ç¹ªè£½ç¥ç¶“å…ƒ
      display() {
        push();
        translate(this.position.x, this.position.y, 0);
        
        // ç™¼å…‰æ•ˆæœ
        if (this.fireRate > 0) {
          noStroke();
          fill(this.hueValue, 80, 100, this.fireRate * 0.3);
          circle(0, 0, 40);
        }
        
        stroke(0, 0, 100);
        fill(this.hueValue, 80, 100, this.fireRate);
        circle(0, 0, 20);
        pop();
      }
    }

    // ========== Synapse Class (çªè§¸) ==========
    class Synapse {
      constructor(inputNeuron, outputNeuron) {
        this.inputNeuron = inputNeuron;
        this.outputNeuron = outputNeuron;
        this.transmission = false;
        this.oscillator = null;
      }

      // å‚³é€ä¿¡è™Ÿ
      transmit() {
        if (!this.transmission) {
          this.transmission = true;
          
          // ç”Ÿæˆéš¨æ©Ÿé »ç‡ (100 Hz ~ 800 Hz)
          let freq = random(100, 800);
          
          // å‰µå»ºæŒ¯ç›ªå™¨
          if (audioContext && audioContext.state === 'running') {
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            gainNode.gain.value = 0.02; // è¼•æŸ”çš„éŸ³é‡
            
            osc.connect(gainNode);
            gainNode.connect(masterGain);
            
            osc.start();
            
            // å¿«é€Ÿæ·¡å‡º
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            osc.stop(audioContext.currentTime + 0.1);
          }
          
          // è§¸ç™¼è¼¸å‡ºç¥ç¶“å…ƒç™¼ç«
          setTimeout(() => {
            this.outputNeuron.fire();
          }, 50);
          
          // å‚³é€çµæŸ
          setTimeout(() => {
            this.transmission = false;
          }, 100);
        }
      }

      // ç¹ªè£½çªè§¸
      display() {
        push();
        if (this.transmission) {
          stroke(120, 100, 100, 150); // å‚³é€ä¸­ç‚ºç¶ è‰²
          strokeWeight(2);
        } else {
          stroke(0, 0, 100, 30); // éœæ­¢æ™‚ç‚ºç™½è‰²åŠé€æ˜
          strokeWeight(1);
        }
        line(this.inputNeuron.position.x, this.inputNeuron.position.y, 0,
             this.outputNeuron.position.x, this.outputNeuron.position.y, 0);
        pop();
      }
    }
    
    // ========== Particle Class (ç…™ç«ç²’å­) ==========
    class Particle {
      constructor(x, y) {
        this.pos = createVector(x, y);
        this.vel = createVector(random(-0.5, 0.5), random(-15, -12)); // æ›´å¿«å‘ä¸Šç™¼å°„
        this.acc = createVector(0, 0.3); // é‡åŠ›
        this.alpha = 255;
        this.alpha2 = 255;
        this.size = random(4, 7);
        this.color_vision = color_vision;
        this.particles = [];
        this.exploded = false;
        this.trail = []; // æ‹–å°¾è»Œè·¡
      }

      update() {
        // ä¿å­˜è»Œè·¡
        if (frameCount % 2 === 0) {
          this.trail.push(this.pos.copy());
          if (this.trail.length > 10) {
            this.trail.shift();
          }
        }
        
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.alpha -= 1.5;
        this.alpha2 -= 1;
      }

      show() {
        push();
        
        // æ ¹æ“š color_vision é¸æ“‡é®®è±”çš„ç…™ç«é¡è‰²
        let c;
        switch(this.color_vision) {
          case 1:
            // äº®ç´«è‰²
            c = color(200, 100, 255, this.alpha);
            break;
          case 2:
            // äº®è—è‰²
            c = color(50, 150, 255, this.alpha);
            break;
          case 3:
            // äº®ç¶ è‰²
            c = color(50, 255, 150, this.alpha);
            break;
          case 4:
            // äº®ç²‰è‰²
            c = color(255, 100, 150, this.alpha);
            break;
          case 5:
            // é‡‘é»ƒè‰²
            c = color(255, 200, 50, this.alpha);
            break;
          default:
            c = color(255, 255, 255, this.alpha);
        }
        
        // ç¹ªè£½æ‹–å°¾
        noFill();
        stroke(red(c), green(c), blue(c), this.alpha * 0.5);
        strokeWeight(2);
        beginShape();
        for (let i = 0; i < this.trail.length; i++) {
          let t = this.trail[i];
          let trailAlpha = map(i, 0, this.trail.length, 0, this.alpha * 0.5);
          stroke(red(c), green(c), blue(c), trailAlpha);
          vertex(t.x, t.y);
        }
        endShape();
        
        // ç¹ªè£½ä¸»ç²’å­ - å¼·çƒˆç™¼å…‰
        noStroke();
        for (let i = 5; i > 0; i--) {
          let glowAlpha = this.alpha * 0.3 / i;
          fill(red(c), green(c), blue(c), glowAlpha);
          ellipse(this.pos.x, this.pos.y, this.size * (1 + i * 0.5), this.size * (1 + i * 0.5));
        }
        
        fill(255, 255, 255, this.alpha); // ç™½è‰²æ ¸å¿ƒ
        ellipse(this.pos.x, this.pos.y, this.size * 0.5, this.size * 0.5);
        
        // ç¹ªè£½çˆ†ç‚¸çš„å­ç²’å­
        for (let p of this.particles) {
          p.update();
          p.show();
        }
        
        pop();
      }

      explode() {
        if (!this.exploded) {
          this.exploded = true;
          // å‰µå»ºæ›´å¤šå­ç²’å­å½¢æˆåœ“å½¢çˆ†ç‚¸
          let numParticles = 30; // å¢åŠ åˆ° 30 å€‹
          for (let i = 0; i < numParticles; i++) {
            let angle = (TWO_PI / numParticles) * i;
            let vel = p5.Vector.fromAngle(angle);
            vel.mult(random(2, 5)); // æ›´å¿«çš„çˆ†ç‚¸é€Ÿåº¦
            this.particles.push(new SubParticle(this.pos.x, this.pos.y, vel, this.color_vision));
          }
          
          // æ·»åŠ ä¸€äº›éš¨æ©Ÿæ–¹å‘çš„ç²’å­
          for (let i = 0; i < 10; i++) {
            let angle = random(TWO_PI);
            let vel = p5.Vector.fromAngle(angle);
            vel.mult(random(1, 4));
            this.particles.push(new SubParticle(this.pos.x, this.pos.y, vel, this.color_vision));
          }
        }
      }

      finished() {
        return this.alpha < 0;
      }
    }

    // ========== SubParticle Class (å­ç²’å­) ==========
    class SubParticle {
      constructor(x, y, vel, colorVision) {
        this.pos = createVector(x, y);
        this.vel = vel;
        this.acc = createVector(0, 0.15); // ç¨å¾®å¢åŠ é‡åŠ›
        this.alpha = 255;
        this.size = random(2, 5);
        this.color_vision = colorVision;
        this.life = 255;
      }

      update() {
        this.vel.add(this.acc);
        this.vel.mult(0.98); // ç©ºæ°£é˜»åŠ›
        this.pos.add(this.vel);
        this.alpha -= 3;
        this.life -= 3;
      }

      show() {
        push();
        noStroke();
        
        // ä½¿ç”¨é®®è±”çš„ç…™ç«é¡è‰²
        let c;
        switch(this.color_vision) {
          case 1:
            // äº®ç´«è‰²
            c = color(200, 100, 255, this.alpha);
            break;
          case 2:
            // äº®è—è‰²
            c = color(50, 150, 255, this.alpha);
            break;
          case 3:
            // äº®ç¶ è‰²
            c = color(50, 255, 150, this.alpha);
            break;
          case 4:
            // äº®ç²‰è‰²
            c = color(255, 100, 150, this.alpha);
            break;
          case 5:
            // é‡‘é»ƒè‰²
            c = color(255, 200, 50, this.alpha);
            break;
          default:
            c = color(255, 255, 255, this.alpha);
        }
        
        // å¼·çƒˆçš„ç™¼å…‰æ•ˆæœ
        for (let i = 3; i > 0; i--) {
          let glowAlpha = this.alpha * 0.4 / i;
          fill(red(c), green(c), blue(c), glowAlpha);
          ellipse(this.pos.x, this.pos.y, this.size * (1 + i * 0.4), this.size * (1 + i * 0.4));
        }
        
        // ç™½è‰²æ ¸å¿ƒ
        fill(255, 255, 255, this.alpha * 0.8);
        ellipse(this.pos.x, this.pos.y, this.size * 0.6, this.size * 0.6);
        
        pop();
      }

      finished() {
        return this.life < 0;
      }
    }
    
    // ========== è¦–è¦ºæ¨¡å¼ 4: Shader Art (SamuelYAN Style) ==========
    function drawShaderPattern() {
      push();
      
      // ä½¿ç”¨ shader
      shader(theShader);
      
      // è¨­å®š uniforms
      theShader.setUniform("u_resolution", [width, height]);
      theShader.setUniform("u_time", millis() / 1000.0);
      theShader.setUniform("u_frame", frameCount / 1.0);
      theShader.setUniform("u_mouse", [mouseX / 100.0, map(mouseY, 0, height, height, 0) / 100.0]);
      
      // ç¹ªè£½å…¨è¢å¹•çŸ©å½¢
      rect(0, 0, width, height);
      
      // é‡ç½® shader
      resetShader();
      
      pop();
    }
    
    // ========== è¦–è¦ºæ¨¡å¼ 5: Particle Fireworks (ç…™ç«æ•ˆæœ) ==========
    function drawParticlesPattern() {
      push();
      
      // åˆ‡æ›åˆ° 2D æ¨¡å¼ç¹ªè£½
      translate(-width/2, -height/2, 0);
      
      // ç¹ªè£½æ¼¸å±¤èƒŒæ™¯ - æ·±è‰²å¤œç©º
      blendMode(BLEND);
      // ç¹ªè£½æ¼¸å±¤å¾ä¸Šåˆ°ä¸‹
      for (let y = 0; y < height; y += 20) {
        let inter = map(y, 0, height, 0, 1);
        let c = lerpColor(color(10, 10, 30), color(30, 20, 50), inter);
        fill(red(c), green(c), blue(c), 50);
        rect(0, y, width, 20);
      }
      
      // ä½¿ç”¨ ADD æ··åˆæ¨¡å¼è®“ç²’å­ç™¼å…‰
      blendMode(ADD);
      
      // æ›´æ–°å’Œç¹ªè£½æ‰€æœ‰ç²’å­
      for (let i = particles.length - 1; i >= 0; i--) {
        if (i < particles.length) {
          if (int(seed) % 2 == 0) {
            particles[i].color_vision = color_vision;
          }
          particles[i].update();
          particles[i].show();
          
          // ç•¶ç²’å­é€Ÿåº¦æ¸›ç·©æ™‚çˆ†ç‚¸(æ›´è‡ªç„¶çš„æ™‚æ©Ÿ)
          if (particles[i].vel.y > -0.5 && !particles[i].exploded) {
            particles[i].explode();
          }
          
          // ç§»é™¤å·²çµæŸçš„ç²’å­ä¸¦å‰µå»ºæ–°çš„
          if (particles[i].finished()) {
            particles.splice(i, 1);
            seed = Math.random() * 1000;
            color_vision = random([1, 2, 3, 4, 5]);
            // åœ¨åº•éƒ¨å‰µå»ºæ–°ç²’å­(åƒç…™ç«ç™¼å°„)
            particles.push(new Particle(
              random(width * 0.3, width * 0.7),
              height - 50
            ));
          }
        }
      }
      
      pop();
    }
    
    // ========== è¦–è¦ºæ¨¡å¼ 6: 3D Heart Pattern (from Processing) ==========
    function draw3DHeartPattern() {
      randomSeed(seed);
      
      push();
      
      // ç§»å‹•åˆ°é è™•
      translate(0, 0, -width * 2);
      
      // æ—‹è½‰å‹•ç•«
      rotateX(frameCount * rotationSpeed);
      rotateY(frameCount * rotationSpeed);
      rotateZ(frameCount * rotationSpeed * 0.5);
      
      // ç¹ªè£½å¿ƒå½¢ç²’å­é›²
      let pNum2 = 200;
      for (let p = 0; p < pNum2; p++) {
        let ttt = sin(time) * sin(time) * sin(time);
        let yt = 13 * cos(time) - 5 * cos(2 * time) - 2 * cos(3 * time) - cos(4 * time);
        
        push();
        translate(ttt * 16, yt, 0);
        rotateX(360 / pNum2 * p);
        rotateY(360 / pNum2 * p);
        rotateZ(360 / pNum2 * p);
        
        // éš¨æ©Ÿé¡è‰²
        let hue = (p * 360 / pNum2 + time * 50) % 360;
        stroke(hue, 80, 100, 50);
        strokeWeight(random(1, 5));
        
        let lSize = width / random(50, 5);
        point(lSize, lSize, lSize);
        
        // é€£æ¥ç·š
        push();
        translate(p * random(0.1, 0.25) + sin(time) * 2, 
                  p * random(0.1, 0.25) + sin(time) * 2, 
                  p * random(0.1, 0.25) + sin(time) * 2);
        rotateX(frameCount / 50);
        rotateY(frameCount / 50);
        rotateZ(frameCount / 50);
        lSize = lSize / 1.1;
        line(-lSize, lSize, lSize, lSize, lSize, lSize);
        pop();
        pop();
      }
      
      // ç«‹æ–¹é«”ç¶²æ ¼
      let cubeSize = width / 4;
      let plus = cubeSize / 2;
      rez = 0.01;
      
      for (let i = -cubeSize / 2; i < cubeSize / 2 + plus; i += plus) {
        for (let j = -cubeSize / 2; j < cubeSize / 2 + plus; j += plus) {
          for (let k = -cubeSize / 2; k < cubeSize / 2 + plus; k += plus) {
            
            let n = noise(i * rez + time, j * rez + time, k * rez + time) * random(0.1, 3);
            
            push();
            translate(i * n, j * n, k * n);
            
            // å…§éƒ¨ç²’å­ç³»çµ±
            let pNum = 5;
            for (let p = 0; p < pNum; p++) {
              translate(p * 0.5, p * 0.5, p * 0.5);
              translate(i * n, j * n, k * n);
              rotateX(360 / pNum * p);
              rotateY(360 / pNum * p);
              rotateZ(360 / pNum * p);
              
              noFill();
              let hue = (time * 100 + p * 72) % 360;
              stroke(hue, 80, 100, 50);
              strokeWeight(random(1, 2));
              let llSize = width / random(200, 100);
              line(0, 0, 0, llSize, llSize, llSize);
            }
            
            // æ—‹è½‰å‹•ç•«
            rotateX(TWO_PI / 4 * random([-1, 1]) * random([1, 2]));
            rotateY(TWO_PI / 4 * random([-1, 1]) * random([1, 2]));
            rotateZ(TWO_PI / 4 * random([-1, 1]) * random([1, 2]));
            
            switch (floor(random(3))) {
              case 0:
                rotateX(random([-1, 1]) * frameCount / 100);
                break;
              case 1:
                rotateY(random([-1, 1]) * frameCount / 100);
                break;
              case 2:
                rotateZ(n * random([-1, 1]) * frameCount / 100);
                break;
            }
            
            let planeSize = width / random([16, 32, 8]);
            
            push();
            translate(i, j, k);
            
            if (random(1) > 0.5) {
              // çƒé«”
              noStroke();
              let hue = (time * 100 + i + j + k) % 360;
              fill(hue, 80, 100, 60);
              sphere(planeSize / 10);
            } else {
              // ç·šæ¢
              noFill();
              let hue = (time * 100 + i + j + k) % 360;
              stroke(hue, 80, 100, 60);
              strokeWeight(random(1, 2));
              
              switch (floor(random(4))) {
                case 0:
                  line(-planeSize / 2, -planeSize / 2, planeSize / 2, -planeSize / 2);
                  break;
                case 1:
                  line(planeSize / 2, -planeSize / 2, planeSize / 2, planeSize / 2);
                  break;
                case 2:
                  line(planeSize / 2, planeSize / 2, -planeSize / 2, planeSize / 2);
                  break;
                case 3:
                  line(-planeSize / 2, planeSize / 2, -planeSize / 2, -planeSize / 2);
                  break;
              }
            }
            pop();
            
            // é€£æ¥ç²’å­
            let px = plus / random(1, 6) / 2 / sin(n + 0.1);
            let py = plus / random(1, 6) / 2 / cos(n + 0.1);
            let pz = plus / random(1, 6) / 2 / (tan(n + 0.1) || 1);
            
            push();
            noStroke();
            let hue = (time * 100 + px + py) % 360;
            fill(hue, 80, 100, 80);
            translate(px, py, pz);
            sphere(width / 1000);
            pop();
            
            noFill();
            stroke(hue, 80, 100, 30);
            strokeWeight(random(0.5, 1.5));
            line(0, 0, 0, px, py, pz);
            
            noStroke();
            fill(hue, 80, 100, 60);
            sphere(planeSize / random(5, 10));
            
            pop();
          }
        }
      }
      
      pop();
    }

    // ========== è¦–è¦ºæ¨¡å¼ 2: Symmetry Pattern (from Processing) ==========
    function drawSymmetryPattern() {
      randomSeed(seed);
      background(0, 0, 5, 100);
      
      push();
      translate(0, 0, -mySize * 4.0);
      
      // éš¨æ©Ÿåˆå§‹æ—‹è½‰
      rotateX(random(TWO_PI));
      rotateY(random(TWO_PI));
      rotateZ(random(TWO_PI));
      
      // å‹•æ…‹æ—‹è½‰ï¼ˆä¸‰é¸ä¸€ï¼‰
      switch (floor(random(3))) {
        case 0:
          rotateX(random([-1, 1]) * frameCount / 100);
          break;
        case 1:
          rotateY(random([-1, 1]) * frameCount / 100);
          break;
        case 2:
          rotateZ(random([-1, 1]) * frameCount / 100);
          break;
      }
      
      let a = 1;
      let b = 2;
      let cubeSize = mySize / (a + a / b) / 2.0;
      let plus = cubeSize / 5;
      
      for (let i = -cubeSize / b; i < cubeSize / b + plus; i += plus * a) {
        for (let j = -cubeSize / b; j < cubeSize / b + plus; j += plus * a) {
          for (let k = -cubeSize / b; k < cubeSize / b + plus; k += plus * a) {
            
            strokeCap(PROJECT);
            let n = noise(i * rez + time, j * rez + time, k * rez + time) * random(1, 10);
            
            push();
            translate(i * n, j * n, k * n);
            
            // è¤‡é›œæ—‹è½‰
            rotateX(TWO_PI / (b * b) * random([-a, a, b, -b]) * random([a, b, a + b, b * b]));
            rotateY(TWO_PI / (b * b) * random([-a, a, b, -b]) * random([a, b, a + b, b * b]));
            rotateZ(TWO_PI / (b * b) * random([-a, a, b, -b]) * random([a, b, a + b, b * b]));
            
            let planeSize = mySize / random([4, 16, 32, 64]);
            
            push();
            translate(i, j, k);
            
            // ç¹ªè£½å¹³é¢æˆ–æ–¹æ¡†
            if (random(1) > 0.33) {
              // å¹³é¢
              noStroke();
              let colorIndex = floor(random(palette.length));
              let c = color(palette[colorIndex]);
              fill(hue(c), saturation(c), brightness(c), 60);
              plane(planeSize);
            } else {
              // ç·šæ¡†
              noFill();
              let colorIndex = floor(random(palette.length));
              let c = color(palette[colorIndex]);
              stroke(hue(c), saturation(c), brightness(c), 80);
              strokeWeight(random(1, 2));
              
              // ç¹ªè£½æ–¹æ¡†çš„å››æ¢é‚Š
              line(-planeSize / 2, -planeSize / 2, planeSize / 2, -planeSize / 2);
              line(planeSize / 2, -planeSize / 2, planeSize / 2, planeSize / 2);
              line(planeSize / 2, planeSize / 2, -planeSize / 2, planeSize / 2);
              line(-planeSize / 2, planeSize / 2, -planeSize / 2, -planeSize / 2);
            }
            pop();
            
            // é€£æ¥ç²’å­
            let px = plus / random(a, int(TWO_PI)) / b / sin(n + 0.1);
            let py = plus / random(a, int(TWO_PI)) / b / cos(n + 0.1);
            let pz = plus / random(a, int(TWO_PI)) / b / (tan(n + 0.1) || 1);
            
            push();
            noStroke();
            let colorIndex = floor(random(palette.length));
            let c = color(palette[colorIndex]);
            fill(hue(c), saturation(c), brightness(c), 80);
            translate(px, py, pz);
            rotateX(random([-1, 1]) * frameCount / 100);
            rotateY(random([-1, 1]) * frameCount / 100);
            rotateZ(random([-1, 1]) * frameCount / 100);
            pop();
            
            // é€£æ¥ç·š
            noFill();
            let colorIndex2 = floor(random(palette.length));
            let c2 = color(palette[colorIndex2]);
            stroke(hue(c2), saturation(c2), brightness(c2), 40);
            strokeWeight(random(0.5, 1) * 2 / random(1, 100));
            line(0, 0, 0, px, py, pz);
            
            pop();
          }
        }
      }
      
      pop();
    }

    // ========== éŸ³è¨Šåˆå§‹åŒ– ==========
    // ========== åˆå§‹åŒ–éŸ³è¨Šç³»çµ± ==========
    function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = 1.2; // å¤§å¹…æå‡éŸ³é‡ ğŸ”Š
        masterGain.connect(audioContext.destination);
        console.log('ğŸ¹ éŸ³è¨Šç³»çµ±å·²åˆå§‹åŒ–, ç‹€æ…‹:', audioContext.state);
        console.log('ğŸ”Š masterGain å·²å‰µå»ºä¸¦é€£æ¥åˆ° destination, éŸ³é‡:', masterGain.gain.value);
      } catch (error) {
        console.error('âŒ éŸ³è¨Šåˆå§‹åŒ–å¤±æ•—:', error);
      }
    }

    // ========== å‰µå»ºè±å¯Œçš„éŸ³è‰²åˆæˆå™¨ ==========
    function createSynth(deviceId, color, noteIndex) {
      // éŸ³éš: äº”è²éŸ³éšæ··åˆè‡ªç„¶éŸ³éš,æ›´è±å¯Œçš„éŸ³åŸŸ
      const scale = [
        130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63, // ä½éŸ³å€
        349.23, 392.00, 440.00, 493.88, 523.25, 587.33, 659.25,         // ä¸­éŸ³å€
        698.46, 783.99, 880.00, 987.77, 1046.50, 1174.66, 1318.51       // é«˜éŸ³å€
      ];
      const frequency = scale[noteIndex % scale.length];
      
      // ğŸ¹ æ›´è±å¯Œçš„è«§æ³¢çµæ§‹ (8 å€‹è«§æ³¢)
      const harmonics = [
        { freq: 1, gain: 1.0, detune: 0 },        // åŸºé »
        { freq: 2, gain: 0.6, detune: 2 },        // ç¬¬äºŒè«§æ³¢ (ç¨å¾®å¤±è«§)
        { freq: 3, gain: 0.4, detune: -3 },       // ç¬¬ä¸‰è«§æ³¢
        { freq: 4, gain: 0.25, detune: 1 },       // ç¬¬å››è«§æ³¢
        { freq: 5, gain: 0.15, detune: -2 },      // ç¬¬äº”è«§æ³¢
        { freq: 6, gain: 0.1, detune: 3 },        // ç¬¬å…­è«§æ³¢
        { freq: 7, gain: 0.08, detune: -1 },      // ç¬¬ä¸ƒè«§æ³¢
        { freq: 8, gain: 0.05, detune: 2 },       // ç¬¬å…«è«§æ³¢
      ];
      
      const oscillators = [];
      const gainNodes = [];
      
      // å‰µå»ºå¤šå€‹æŒ¯ç›ªå™¨æ¨¡æ“¬è±å¯Œçš„æ³›éŸ³,ä¸¦æ·»åŠ å¤±è«§æ•ˆæœ
      harmonics.forEach(harmonic => {
        const osc = audioContext.createOscillator();
        osc.type = 'sine'; // ä½¿ç”¨æ­£å¼¦æ³¢ç–ŠåŠ 
        osc.frequency.value = frequency * harmonic.freq;
        osc.detune.value = harmonic.detune; // æ·»åŠ å¾®å°å¤±è«§,è®“è²éŸ³æ›´æœ‰ç”Ÿå‘½åŠ›
        
        const gain = audioContext.createGain();
        gain.gain.value = 0;
        
        osc.connect(gain);
        oscillators.push(osc);
        gainNodes.push({ node: gain, maxGain: harmonic.gain });
      });
      
      // æ·»åŠ ä½é »æŒ¯ç›ªå™¨ (LFO) ç”¨æ–¼èª¿è£½
      const lfo = audioContext.createOscillator();
      lfo.frequency.value = 5; // 5Hz èª¿è£½
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 15; // èª¿è£½æ·±åº¦
      lfo.connect(lfoGain);
      
      // ä¸»å¢ç›Šç¯€é»
      const masterGainNode = audioContext.createGain();
      masterGainNode.gain.value = 0;
      
      // å¤šæ®µæ¿¾æ³¢å™¨ç³»çµ±
      const filter1 = audioContext.createBiquadFilter();
      filter1.type = 'lowpass';
      filter1.frequency.value = 4000 + (noteIndex * 150); // æ›´æ˜äº®
      filter1.Q.value = 2; // å¢å¼·å…±é³´
      
      const filter2 = audioContext.createBiquadFilter();
      filter2.type = 'highpass';
      filter2.frequency.value = 80; // å»é™¤ä½é »é›œéŸ³
      filter2.Q.value = 0.5;
      
      // LFO èª¿è£½æ¿¾æ³¢å™¨é »ç‡,ç”¢ç”Ÿé¡«éŸ³æ•ˆæœ
      lfoGain.connect(filter1.frequency);
      
      // å£“ç¸®å™¨ - è®“è²éŸ³æ›´æœ‰åŠ›åº¦
      const compressor = audioContext.createDynamicsCompressor();
      compressor.threshold.value = -20;
      compressor.knee.value = 40;
      compressor.ratio.value = 16;
      compressor.attack.value = 0.001;
      compressor.release.value = 0.2;
      
      // æ®˜éŸ¿æ•ˆæœ - æ¨¡æ“¬ç©ºé–“æ„Ÿ
      const convolver = audioContext.createConvolver();
      createReverb(convolver);
      const reverbGain = audioContext.createGain();
      reverbGain.gain.value = 0.5; // å¤§å¹…å¢åŠ æ®˜éŸ¿ (å¾ 0.25 æå‡åˆ° 0.5)
      
      // å»¶é²æ•ˆæœ - å¢åŠ æ·±åº¦
      const delay = audioContext.createDelay();
      delay.delayTime.value = 0.15; // 150ms å»¶é²
      const delayGain = audioContext.createGain();
      delayGain.gain.value = 0.5; // å¤§å¹…å¢åŠ å»¶é² (å¾ 0.3 æå‡åˆ° 0.5)
      
      // é€£æ¥æ‰€æœ‰ç¯€é» - æ›´è¤‡é›œçš„è¨Šè™Ÿéˆ
      gainNodes.forEach(g => g.node.connect(masterGainNode));
      masterGainNode.connect(filter2); // å…ˆé«˜é€šæ¿¾æ³¢
      filter2.connect(filter1);         // å†ä½é€šæ¿¾æ³¢
      filter1.connect(compressor);      // å£“ç¸®
      
      // ä¹¾éŸ³è·¯å¾‘
      compressor.connect(masterGain);
      
      // æ¿•éŸ³è·¯å¾‘ 1: æ®˜éŸ¿
      compressor.connect(convolver);
      convolver.connect(reverbGain);
      reverbGain.connect(masterGain);
      
      // æ¿•éŸ³è·¯å¾‘ 2: å»¶é²
      compressor.connect(delay);
      delay.connect(delayGain);
      delayGain.connect(delay); // åé¥‹å»¶é²
      delayGain.connect(masterGain);
      
      // å•Ÿå‹•æ‰€æœ‰æŒ¯ç›ªå™¨å’Œ LFO
      oscillators.forEach(osc => osc.start());
      lfo.start();
      
      return {
        oscillators,
        gainNodes,
        masterGainNode,
        filter1,
        filter2,
        lfo,
        attack: () => {
          const now = audioContext.currentTime;
          console.log('ğŸ¹ Attack è¢«èª¿ç”¨, é »ç‡:', frequency.toFixed(2), 'Hz');
          
          // ğŸ¹ æ›´æœ‰è¡¨ç¾åŠ›çš„ ADSR åŒ…çµ¡
          gainNodes.forEach((g, index) => {
            g.node.gain.cancelScheduledValues(now);
            g.node.gain.setValueAtTime(0, now);
            // æ ¹æ“šè«§æ³¢ä½ç½®èª¿æ•´ Attack æ™‚é–“
            const attackTime = 0.005 + (index * 0.001);
            // å¿«é€Ÿ Attack - å¤§å¹…æå‡éŸ³é‡ ğŸ”Š
            g.node.gain.linearRampToValueAtTime(g.maxGain * 1.5, now + attackTime);
            // Decay to Sustain - ä¿æŒæ›´é«˜çš„æŒçºŒéŸ³é‡
            g.node.gain.exponentialRampToValueAtTime(g.maxGain * 0.9, now + 0.15);
          });
          
          console.log('ğŸµ è¨­å®šäº†', gainNodes.length, 'å€‹è«§æ³¢å¢ç›Š');
          
          // æ¿¾æ³¢å™¨åŒ…çµ¡ - æ›´å‹•æ…‹çš„éŸ³è‰²è®ŠåŒ–
          filter1.frequency.cancelScheduledValues(now);
          filter1.frequency.setValueAtTime(6000, now);
          filter1.frequency.exponentialRampToValueAtTime(4000 + (noteIndex * 150), now + 0.08);
          
          filter2.frequency.cancelScheduledValues(now);
          filter2.frequency.setValueAtTime(60, now);
          filter2.frequency.exponentialRampToValueAtTime(80, now + 0.05);
        },
        release: () => {
          const now = audioContext.currentTime;
          
          // ğŸ¹ æ›´é•·çš„ Release - é¤˜éŸ³ç¹æ¨‘ (1.2 ç§’)
          gainNodes.forEach((g, index) => {
            g.node.gain.cancelScheduledValues(now);
            g.node.gain.setValueAtTime(g.node.gain.value, now);
            // ä¸åŒè«§æ³¢æœ‰ä¸åŒçš„è¡°æ¸›æ™‚é–“
            const releaseTime = 1.2 + (index * 0.1);
            g.node.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
          });
          
          // æ¿¾æ³¢å™¨ç·©æ…¢é—œé–‰
          filter1.frequency.cancelScheduledValues(now);
          filter1.frequency.setValueAtTime(filter1.frequency.value, now);
          filter1.frequency.exponentialRampToValueAtTime(800, now + 1.2);
        },
        stop: () => {
          const now = audioContext.currentTime;
          gainNodes.forEach(g => {
            g.node.gain.cancelScheduledValues(now);
            g.node.gain.setValueAtTime(g.node.gain.value, now);
            g.node.gain.linearRampToValueAtTime(0, now + 0.1);
          });
          setTimeout(() => {
            oscillators.forEach(osc => osc.stop());
            lfo.stop();
          }, 200);
        }
      };
    }
    
    // ========== å‰µå»ºæ®˜éŸ¿æ•ˆæœ ==========
    function createReverb(convolver) {
      const sampleRate = audioContext.sampleRate;
      const length = sampleRate * 2; // 2ç§’æ®˜éŸ¿
      const impulse = audioContext.createBuffer(2, length, sampleRate);
      
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          // æŒ‡æ•¸è¡°æ¸›çš„ç™½å™ªéŸ³
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
        }
      }
      
      convolver.buffer = impulse;
    }

    // ========== è™•ç†ç©å®¶äº’å‹• ==========
    function handlePlayerInteraction(deviceId, payload) {
      console.log('ğŸ® handlePlayerInteraction è¢«èª¿ç”¨', { deviceId, payload });
      
      const now = Date.now();
      
      // ç¢ºä¿éŸ³è¨Šç³»çµ±å·²å•Ÿå‹•
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('ğŸ”Š éŸ³è¨Šå·²é€šéäº’å‹•å•Ÿå‹•');
        });
      }
      
      // ç¢ºä¿ç©å®¶å­˜åœ¨
      if (!players.has(deviceId)) {
        const color = playerColors[colorIndex % playerColors.length];
        const noteIndex = colorIndex % 15; // 15å€‹éŸ³ç¬¦
        colorIndex++;
        
        players.set(deviceId, {
          color: color,
          name: deviceId,
          noteIndex: noteIndex,
          lastActivity: now,
          interactions: 0
        });
        
        console.log('ğŸ‘¤ å‰µå»ºæ–°ç©å®¶:', deviceId, 'éŸ³ç¬¦:', noteIndex);
      }
      
      const player = players.get(deviceId);
      player.lastActivity = now;
      
      if (payload.pressed) {
        // æŒ‰ä¸‹ - è§¸ç™¼è¦–è¦ºå’Œè²éŸ³
        player.interactions++;
        
        // å‰µå»ºè¦–è¦ºæ•ˆæœ
        createVisualEffect(player);
        
        // å‰µå»ºæˆ–è§¸ç™¼éŸ³è¨Šï¼ˆé‹¼ç´éŸ³è‰²ï¼‰
        if (!synths.has(deviceId)) {
          const synth = createSynth(deviceId, player.color, player.noteIndex);
          synths.set(deviceId, synth);
          console.log('ğŸ¹ å‰µå»ºæ–°çš„é‹¼ç´éŸ³è‰², è¨­å‚™:', deviceId, 'éŸ³ç¬¦ç´¢å¼•:', player.noteIndex);
        }
        synths.get(deviceId).attack();
        console.log('ğŸµ è§¸ç™¼éŸ³ç¬¦, è¨­å‚™:', deviceId);
        
        // ç§»é™¤è‡ªå‹•åˆ‡æ›æ¨¡å¼ - åªèƒ½é€šéæŒ‰éˆ•æˆ–æŒ‰éµåˆ‡æ›
        // (åŸæœ¬æ¯3æ¬¡äº’å‹•æœƒè‡ªå‹•åˆ‡æ›)
        
      } else {
        // é‡‹æ”¾ - è²éŸ³è¡°æ¸›(é‹¼ç´è‡ªç„¶è¡°æ¸›)
        if (synths.has(deviceId)) {
          synths.get(deviceId).release();
        }
      }
      
      updatePlayersList();
    }
    
    // ========== æ›´æ–°æ¨¡å¼é¡¯ç¤º ==========
    function updateModeDisplay() {
      const modeNames = {
        'neurons': 'Neural Network ğŸ§ ',
        '3dheart': '3D Heart â¤ï¸',
        'symmetry': 'Symmetry ğŸ”·',
        'shader': 'Shader Art ğŸŒˆ'
      };
      document.getElementById('currentMode').textContent = modeNames[currentMode] || currentMode.toUpperCase();
    }
    
    // ========== æ’­æ”¾è±å¯Œçš„æ¸¬è©¦å’Œå¼¦ ==========
    function playTestBeep() {
      try {
        if (!audioContext) {
          console.warn('âš ï¸ audioContext ä¸å­˜åœ¨');
          return;
        }
        
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        
        // å‰µå»ºå’Œå¼¦ (C major - C E G)
        const frequencies = [261.63, 329.63, 392.00]; // C E G
        const now = audioContext.currentTime;
        
        frequencies.forEach((freq, index) => {
          // ä¸»éŸ³
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          
          osc.frequency.value = freq;
          osc.type = 'sine';
          
          gain.gain.value = 0;
          
          osc.connect(gain);
          gain.connect(audioContext.destination);
          
          osc.start(now);
          
          // éŒ¯é–‹ Attack ç”¢ç”Ÿç¶éŸ³æ•ˆæœ
          const delay = index * 0.05;
          gain.gain.setValueAtTime(0, now + delay);
          gain.gain.linearRampToValueAtTime(0.15, now + delay + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.4);
          
          osc.stop(now + delay + 0.5);
        });
        
        console.log('ğŸ”Š æ¸¬è©¦å’Œå¼¦å·²æ’­æ”¾ (C Major)');
      } catch (error) {
        console.error('âŒ æ’­æ”¾æ¸¬è©¦è²éŸ³å¤±æ•—:', error);
      }
    }

    // ========== å‰µå»ºè¦–è¦ºæ•ˆæœ ==========
    function createVisualEffect(player) {
      // åœ¨ç•¶å‰æ¨¡å¼ä¸‹å¢åŠ éš¨æ©Ÿæ€§å’Œå‹•æ…‹è®ŠåŒ–
      // æ”¹è®Šæ—‹è½‰é€Ÿåº¦
      rotationSpeed = random(0.005, 0.02);
      
      // æ”¹è®Š rez å€¼å½±éŸ¿å™ªè²
      rez = random(0.001, 0.02);
      
      // è§¸ç™¼æ™‚éš¨æ©Ÿæ”¹è®Š seed çš„ä¸€éƒ¨åˆ†ï¼ˆä¿æŒéƒ¨åˆ†ç©©å®šæ€§ï¼‰
      seed = seed + random(-100, 100);
    }

    // ========== æ›´æ–°ç©å®¶åˆ—è¡¨ ==========
    function updatePlayersList() {
      const now = Date.now();
      const playersList = document.getElementById('playersList');
      playersList.innerHTML = '';
      document.getElementById('playerCount').textContent = players.size;
      
      players.forEach((player, deviceId) => {
        const isActive = now - player.lastActivity < 3000;
        const div = document.createElement('div');
        div.className = `player-item ${isActive ? 'active' : ''}`;
        div.innerHTML = `
          <div class="player-color" style="background: ${player.color}"></div>
          <div class="player-name">${player.name}</div>
        `;
        playersList.appendChild(div);
      });
    }

    // ========== WebSocket ==========
    function connectWebSocket() {
      ws = new WebSocket(WS_URL);
      
      ws.onopen = () => {
        console.log('âœ… WebSocket é€£æ¥æˆåŠŸ');
        document.getElementById('connectionDot').classList.add('connected');
        document.getElementById('connectionText').textContent = 'å·²é€£æ¥';
        
        ws.send(JSON.stringify({
          type: 'subscribe',
          topic: 'art/button/#'
        }));
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.topic && data.topic.includes('art/button')) {
            const payload = JSON.parse(data.payload);
            const deviceId = data.topic.split('/').pop();
            handlePlayerInteraction(deviceId, payload);
          }
        } catch (e) {
          console.error('è§£æéŒ¯èª¤:', e);
        }
      };
      
      ws.onerror = (error) => {
        console.error('âŒ WebSocket éŒ¯èª¤:', error);
      };
      
      ws.onclose = () => {
        console.log('ğŸ”Œ WebSocket å·²æ–·é–‹');
        document.getElementById('connectionDot').classList.remove('connected');
        setTimeout(connectWebSocket, 3000);
      };
    }

    // ========== æ¸¬è©¦è²éŸ³æŒ‰éˆ• ==========
    document.getElementById('testSoundBtn').addEventListener('click', async () => {
      console.log('ğŸ”Š æ¸¬è©¦è²éŸ³æŒ‰éˆ•è¢«é»æ“Š');
      
      try {
        // ç¢ºä¿éŸ³è¨Šç³»çµ±å­˜åœ¨
        if (!audioContext) {
          console.log('âš ï¸ audioContext ä¸å­˜åœ¨,é‡æ–°åˆå§‹åŒ–');
          initAudio();
        }
        
        // ç¢ºä¿éŸ³è¨Šä¸Šä¸‹æ–‡å·²å•Ÿå‹•
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
          console.log('ğŸ”Š éŸ³è¨Šä¸Šä¸‹æ–‡å·²æ¢å¾©, ç‹€æ…‹:', audioContext.state);
        }
        
        console.log('ğŸµ ç•¶å‰éŸ³è¨Šç‹€æ…‹:', audioContext.state);
        console.log('ğŸ”Š masterGain å­˜åœ¨:', !!masterGain);
        
        // æ’­æ”¾ç°¡å–®çš„æ¸¬è©¦éŸ³ - ç›´æ¥é€£æ¥åˆ° destination
        const testOsc = audioContext.createOscillator();
        const testGain = audioContext.createGain();
        
        testOsc.type = 'sine';
        testOsc.frequency.value = 440; // A4 éŸ³ç¬¦
        testGain.gain.value = 0;
        
        testOsc.connect(testGain);
        testGain.connect(audioContext.destination); // ç›´æ¥é€£æ¥,ä¸é€šé masterGain
        
        testOsc.start();
        
        // ADSR åŒ…çµ¡
        const now = audioContext.currentTime;
        testGain.gain.setValueAtTime(0, now);
        testGain.gain.linearRampToValueAtTime(0.3, now + 0.01); // Attack
        testGain.gain.linearRampToValueAtTime(0.2, now + 0.1);  // Decay
        testGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);    // Release
        
        testOsc.stop(now + 0.6);
        
        console.log('ğŸµ æ¸¬è©¦éŸ³å·²æ’­æ”¾ (440 Hz, æŒçºŒ 0.5 ç§’)');
        
        // æ”¹è®ŠæŒ‰éˆ•æ–‡å­—çµ¦äºˆåé¥‹
        const btn = document.getElementById('testSoundBtn');
        const originalText = btn.textContent;
        btn.textContent = 'âœ… è²éŸ³å·²æ’­æ”¾!';
        btn.style.background = '#00ff88';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '#00ff88';
        }, 1000);
        
      } catch (error) {
        console.error('âŒ æ¸¬è©¦è²éŸ³éŒ¯èª¤:', error);
        alert('éŸ³è¨Šæ’­æ”¾å¤±æ•—: ' + error.message);
      }
    });

    // ========== Join ==========
    document.getElementById('joinBtn').addEventListener('click', () => {
      myDeviceId = document.getElementById('deviceIdInput').value.trim();
      if (!myDeviceId) {
        alert('è«‹è¼¸å…¥è¨­å‚™ ID');
        return;
      }
      
      document.getElementById('joinPanel').classList.add('hidden');
      connectWebSocket();
      
      // æ¢å¾©éŸ³è¨Šä¸Šä¸‹æ–‡
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('ğŸ”Š éŸ³è¨Šå·²å•Ÿå‹•');
        });
      }
      
      updateModeDisplay();
    });
    
    // ========== æ¨¡å¼åˆ‡æ›æŒ‰éˆ• ==========
    document.getElementById('nextModeBtn').addEventListener('click', () => {
      modeIndex = (modeIndex + 1) % modes.length;
      currentMode = modes[modeIndex];
      updateModeDisplay();
    });

    // ========== çª—å£èª¿æ•´ ==========
    function windowResized() {
      mySize = min(windowWidth, windowHeight) * 0.9;
      resizeCanvas(windowWidth, windowHeight);
    }

    // ========== æ¸¬è©¦ï¼šæ»‘é¼ é»æ“Š ==========
    function mousePressed() {
      console.log('ğŸ–±ï¸ æ»‘é¼ æŒ‰ä¸‹, ä½ç½®:', mouseX, mouseY);
      
      // å…ˆæ’­æ”¾ç°¡å–®çš„æ¸¬è©¦éŸ³
      playTestBeep();
      
      // æ¢å¾©éŸ³è¨Šä¸Šä¸‹æ–‡(è™•ç†ç€è¦½å™¨è‡ªå‹•æ’­æ”¾é™åˆ¶)
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('ğŸ”Š éŸ³è¨Šä¸Šä¸‹æ–‡å·²é€šéæ»‘é¼ é»æ“Šå•Ÿå‹•');
        });
      }
      
      console.log('ğŸ”Š éŸ³è¨Šä¸Šä¸‹æ–‡ç‹€æ…‹:', audioContext ? audioContext.state : 'audioContext ä¸å­˜åœ¨');
      
      // åœ¨ç¥ç¶“ç¶²çµ¡æ¨¡å¼ä¸‹,é»æ“Šæ»‘é¼ æ·»åŠ æ–°ç¥ç¶“å…ƒ
      if (currentMode === 'neurons') {
        // å°‡æ»‘é¼ åº§æ¨™è½‰æ›åˆ°3Dç©ºé–“
        let x = map(mouseX, 0, width, -width/2, width/2);
        let y = map(mouseY, 0, height, -height/2, height/2);
        
        // å‰µå»ºæ–°ç¥ç¶“å…ƒ
        let newNeuron = new Neuron(x, y);
        neurons.push(newNeuron);
        
        // èˆ‡é™„è¿‘çš„ç¥ç¶“å…ƒå»ºç«‹çªè§¸é€£æ¥ (5% æ©Ÿç‡)
        for (let other of neurons) {
          if (other !== newNeuron && random() < 0.05) {
            connections.push(new Synapse(newNeuron, other));
            connections.push(new Synapse(other, newNeuron));
          }
        }
        
        // è®“æ–°ç¥ç¶“å…ƒç«‹å³ç™¼ç«
        newNeuron.fire();
      }
      
      // å¦‚æœé‚„æœªåŠ å…¥,ä½¿ç”¨è‡¨æ™‚ ID
      const deviceId = myDeviceId || 'local-temp';
      handlePlayerInteraction(deviceId, { pressed: true });
    }

    function mouseReleased() {
      const deviceId = myDeviceId || 'local-temp';
      handlePlayerInteraction(deviceId, { pressed: false });
    }
    
    // ========== éµç›¤æ§åˆ¶ ==========
    function keyPressed() {
      // å¦‚æœç„¦é»åœ¨è¼¸å…¥æ¡†,ä¸åŸ·è¡Œéµç›¤å¿«æ·éµ
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
        return;
      }
      
      if (key === ' ') {
        // ç©ºç™½éµåˆ‡æ›æ¨¡å¼
        modeIndex = (modeIndex + 1) % modes.length;
        currentMode = modes[modeIndex];
        updateModeDisplay();
      } else if (key === 's' || key === 'S') {
        // å„²å­˜æˆªåœ–
        saveCanvas('audiovisual-art', 'png');
      }
    }
  </script>
</body>
</html>
