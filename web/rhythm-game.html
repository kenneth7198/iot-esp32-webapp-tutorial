<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ESP32 ç¯€å¥éŸ³æ¨‚éŠæˆ² - 9 Keys</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* éŠæˆ²å€åŸŸ */
    #gameArea {
      flex: 1;
      position: relative;
      background: linear-gradient(180deg, #0f0f1e 0%, #1a1a2e 100%);
      overflow: hidden;
    }

    /* éŸ³ç¬¦è»Œé“å®¹å™¨ */
    #tracks {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 900px;
      height: 100%;
      display: flex;
      justify-content: space-between;
      gap: 2px;
    }

    /* å–®ä¸€è»Œé“ */
    .track {
      flex: 1;
      position: relative;
      background: rgba(255, 255, 255, 0.05);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* è»Œé“åˆ†æ•¸é¡¯ç¤º */
    .track-score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: #ffd700;
      padding: 5px 10px;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: bold;
      text-align: center;
      min-width: 60px;
      z-index: 10;
      border: 1px solid rgba(255, 215, 0, 0.3);
    }

    .track-score .score-num {
      font-size: 1.1rem;
      display: block;
      color: #ffd700;
    }

    .track-score .accuracy {
      font-size: 0.7rem;
      color: #aaa;
      display: block;
      margin-top: 2px;
    }

    /* éŸ³ç¬¦ */
    .note {
      position: absolute;
      width: 100%;
      height: 60px;
      border-radius: 8px;
      transition: all 0.1s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      font-size: 1.2rem;
    }

    /* è§¸ç™¼å€ï¼ˆåº•éƒ¨åˆ¤å®šå€ï¼‰ */
    .hit-zone {
      position: absolute;
      bottom: 80px;
      left: 0;
      width: 100%;
      height: 80px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: rgba(255, 255, 255, 0.5);
      transition: all 0.2s ease;
    }

    .hit-zone.active {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      transform: scale(1.05);
    }

    .hit-zone.perfect {
      background: rgba(0, 255, 0, 0.3);
      border-color: #00ff00;
    }

    .hit-zone.good {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
    }

    .hit-zone.miss {
      background: rgba(255, 0, 0, 0.3);
      border-color: #ff0000;
    }

    /* åˆ¤å®šæ–‡å­— */
    .judgment {
      position: absolute;
      bottom: 200px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 3rem;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      animation: judgmentFade 0.8s ease-out forwards;
      pointer-events: none;
    }

    .judgment.perfect { color: #00ff00; text-shadow: 0 0 30px #00ff00; }
    .judgment.good { color: #ffd700; text-shadow: 0 0 30px #ffd700; }
    .judgment.miss { color: #ff0000; text-shadow: 0 0 30px #ff0000; }

    @keyframes judgmentFade {
      0% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
    }

    /* æ§åˆ¶é¢æ¿ */
    #controlPanel {
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      color: white;
    }

    #scoreBoard {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin-bottom: 10px;
    }

    .score-item {
      text-align: center;
    }

    .score-value {
      font-size: 2rem;
      font-weight: bold;
      color: #ffd700;
    }

    .score-label {
      font-size: 0.9rem;
      color: #aaa;
    }

    /* è¨­å‚™ç‹€æ…‹æŒ‡ç¤ºå™¨ */
    #deviceStatus {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-top: 10px;
    }

    .device-indicator {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #333;
      border: 2px solid #555;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      color: #aaa;
    }

    .device-indicator.connected {
      background: #00ff00;
      border-color: #00ff00;
      color: white;
      box-shadow: 0 0 10px #00ff00;
    }

    .device-indicator.active {
      animation: pulse 0.3s ease;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }

    /* æŒ‰éˆ•æ¨£å¼ */
    .game-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .game-btn:hover {
      transform: scale(1.05);
    }

    /* é¡è‰²é…ç½®ï¼ˆ9å€‹è»Œé“ï¼‰ */
    .track:nth-child(1) .note { background: linear-gradient(180deg, #e74c3c, #c0392b); }
    .track:nth-child(2) .note { background: linear-gradient(180deg, #3498db, #2980b9); }
    .track:nth-child(3) .note { background: linear-gradient(180deg, #f1c40f, #f39c12); }
    .track:nth-child(4) .note { background: linear-gradient(180deg, #2ecc71, #27ae60); }
    .track:nth-child(5) .note { background: linear-gradient(180deg, #9b59b6, #8e44ad); }
    .track:nth-child(6) .note { background: linear-gradient(180deg, #e67e22, #d35400); }
    .track:nth-child(7) .note { background: linear-gradient(180deg, #1abc9c, #16a085); }
    .track:nth-child(8) .note { background: linear-gradient(180deg, #34495e, #2c3e50); }
    .track:nth-child(9) .note { background: linear-gradient(180deg, #ff69b4, #ff1493); }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- éŠæˆ²å€åŸŸ -->
    <div id="gameArea">
      <div id="tracks">
        <!-- 9 å€‹è»Œé“å°‡ç”± JavaScript å‹•æ…‹ç”Ÿæˆ -->
      </div>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div id="controlPanel">
      <!-- åˆ†æ•¸æ¿ -->
      <div id="scoreBoard">
        <div class="score-item">
          <div class="score-value" id="score">0</div>
          <div class="score-label">åˆ†æ•¸</div>
        </div>
        <div class="score-item">
          <div class="score-value" id="combo">0</div>
          <div class="score-label">é€£æ“Š</div>
        </div>
        <div class="score-item">
          <div class="score-value" id="accuracy">100%</div>
          <div class="score-label">æº–ç¢ºåº¦</div>
        </div>
      </div>

      <!-- è¨­å‚™ç‹€æ…‹ -->
      <div id="deviceStatus"></div>

      <!-- æ§åˆ¶æŒ‰éˆ• -->
      <div class="d-flex justify-content-center gap-2 mt-3">
        <button id="btnConnect" class="game-btn btn-primary">
          <i class="fas fa-link"></i> é€£ç·š MQTT
        </button>
        <button id="btnStart" class="game-btn btn-success" disabled>
          <i class="fas fa-play"></i> é–‹å§‹éŠæˆ²
        </button>
        <button id="btnPause" class="game-btn btn-warning" disabled>
          <i class="fas fa-pause"></i> æš«åœ
        </button>
        <button id="btnReset" class="game-btn btn-danger">
          <i class="fas fa-redo"></i> é‡ç½®
        </button>
        <button id="btnMusic" class="game-btn btn-info">
          <i class="fas fa-music"></i> <span id="musicStatus">é–‹å•ŸéŸ³æ¨‚</span>
        </button>
      </div>

      <!-- éŸ³æ¨‚æ§åˆ¶ -->
      <div class="d-flex justify-content-center align-items-center gap-3 mt-2">
        <label class="text-white small">
          <i class="fas fa-volume-up"></i> éŸ³é‡
        </label>
        <input type="range" id="volumeSlider" class="form-range" 
               style="width: 150px;" min="0" max="100" value="70">
        <span class="text-white small" id="volumeValue">70%</span>
        
        <label class="text-white small ms-3">
          <i class="fas fa-drum"></i> BPM
        </label>
        <input type="number" id="bpmInput" class="form-control form-control-sm" 
               style="width: 80px;" min="60" max="200" value="120">
      </div>

      <!-- éŠæˆ²é›£åº¦è¨­å®š -->
      <div class="d-flex justify-content-center align-items-center gap-3 mt-2">
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="speedVariation" checked>
          <label class="form-check-label text-white small" for="speedVariation">
            <i class="fas fa-tachometer-alt"></i> é€Ÿåº¦è®ŠåŒ–
          </label>
        </div>
        
        <label class="text-white small ms-2">
          <i class="fas fa-arrow-down"></i> æœ€å°é€Ÿåº¦
        </label>
        <input type="number" id="minSpeed" class="form-control form-control-sm" 
               style="width: 70px;" min="0.5" max="3" step="0.1" value="1.2">
        
        <label class="text-white small">
          <i class="fas fa-arrow-down"></i> æœ€å¤§é€Ÿåº¦
        </label>
        <input type="number" id="maxSpeed" class="form-control form-control-sm" 
               style="width: 70px;" min="1" max="5" step="0.1" value="2.5">
        
        <label class="text-white small ms-2">
          <i class="fas fa-clock"></i> é–“éš”
        </label>
        <input type="number" id="spawnInterval" class="form-control form-control-sm" 
               style="width: 80px;" min="1000" max="8000" step="500" value="3500">
        <span class="text-white small">ms</span>
      </div>

      <!-- MQTT è¨­å®šï¼ˆå¯æŠ˜ç–Šï¼‰ -->
      <div class="mt-2">
        <button class="btn btn-sm btn-outline-light" type="button" data-bs-toggle="collapse" data-bs-target="#mqttSettings">
          <i class="fas fa-cog"></i> MQTT è¨­å®š
        </button>
        <div class="collapse mt-2" id="mqttSettings">
          <div class="row g-2">
            <div class="col-md-12">
              <label class="form-label small">MQTT Broker URL</label>
              <input type="text" id="mqttUrl" class="form-control form-control-sm" 
                     value="ws://192.168.100.200:9001">
              <small class="text-muted">è¨‚é–±ä¸»é¡Œ: esp32/device-01/touch ~ esp32/device-09/touch</small>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // ========== éŠæˆ²è¨­å®š ==========
    const CONFIG = {
      trackCount: 9,              // 9 å€‹è»Œé“ï¼ˆ9 å€‹ç©å®¶ï¼‰
      noteSpeedMin: 1.2,          // æœ€å°ä¸‹é™é€Ÿåº¦ (px/frame) - é™ä½
      noteSpeedMax: 2.5,          // æœ€å¤§ä¸‹é™é€Ÿåº¦ (px/frame) - é™ä½
      perfectWindow: 50,          // Perfect åˆ¤å®šç¯„åœ (px)
      goodWindow: 100,            // Good åˆ¤å®šç¯„åœ (px)
      noteHeight: 60,             // éŸ³ç¬¦é«˜åº¦
      spawnInterval: 3500,        // æ¯å€‹è»Œé“éŸ³ç¬¦ç”Ÿæˆé–“éš” (ms) - å¢åŠ é–“éš”
      hitZoneY: window.innerHeight - 160,  // åˆ¤å®šå€ Y åº§æ¨™
      speedVariation: true        // æ˜¯å¦å•Ÿç”¨é€Ÿåº¦è®ŠåŒ–
    };

    // ========== éŸ³æ¨‚ç³»çµ± ==========
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const musicState = {
      playing: false,
      bpm: 120,
      volume: 0.7,
      masterGain: null,
      kickScheduler: null,
      snareScheduler: null,
      hihatScheduler: null,
      bassScheduler: null
    };

    // å‰µå»ºä¸»éŸ³é‡æ§åˆ¶
    musicState.masterGain = audioContext.createGain();
    musicState.masterGain.connect(audioContext.destination);
    musicState.masterGain.gain.value = musicState.volume;

    // å‰µå»ºå¤§é¼“éŸ³æ•ˆï¼ˆKickï¼‰
    function playKick(time) {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
      
      gain.gain.setValueAtTime(1, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
      
      osc.connect(gain);
      gain.connect(musicState.masterGain);
      
      osc.start(time);
      osc.stop(time + 0.5);
    }

    // å‰µå»ºå°é¼“éŸ³æ•ˆï¼ˆSnareï¼‰
    function playSnare(time) {
      const noise = audioContext.createBufferSource();
      const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < buffer.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      
      noise.buffer = buffer;
      
      const filter = audioContext.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 1000;
      
      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(musicState.masterGain);
      
      noise.start(time);
      noise.stop(time + 0.2);
    }

    // å‰µå»ºHi-HatéŸ³æ•ˆ
    function playHiHat(time) {
      const noise = audioContext.createBufferSource();
      const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < buffer.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      
      noise.buffer = buffer;
      
      const filter = audioContext.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 7000;
      
      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.3, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(musicState.masterGain);
      
      noise.start(time);
      noise.stop(time + 0.05);
    }

    // å‰µå»ºä½éŸ³ï¼ˆBassï¼‰
    function playBass(time, note = 55) {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = 'sawtooth';
      osc.frequency.value = note;
      
      gain.gain.setValueAtTime(0.3, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
      
      osc.connect(gain);
      gain.connect(musicState.masterGain);
      
      osc.start(time);
      osc.stop(time + 0.3);
    }

    // ç¯€å¥æ¨¡å¼ç·¨æ’
    function scheduleDrumPattern() {
      if (!musicState.playing) return;
      
      const beatDuration = 60 / musicState.bpm;
      const currentTime = audioContext.currentTime;
      
      // 4/4 æ‹ç¯€å¥æ¨¡å¼
      // Beat 1, 3: Kick + Hi-Hat
      playKick(currentTime);
      playHiHat(currentTime);
      playBass(currentTime, 55);
      
      // Beat 2, 4: Snare + Hi-Hat
      setTimeout(() => {
        if (musicState.playing) {
          playSnare(audioContext.currentTime);
          playHiHat(audioContext.currentTime);
        }
      }, beatDuration * 1000);
      
      // Off-beat Hi-Hats
      setTimeout(() => {
        if (musicState.playing) playHiHat(audioContext.currentTime);
      }, beatDuration * 500);
      
      setTimeout(() => {
        if (musicState.playing) playHiHat(audioContext.currentTime);
      }, beatDuration * 1500);
      
      // Beat 3
      setTimeout(() => {
        if (musicState.playing) {
          playKick(audioContext.currentTime);
          playHiHat(audioContext.currentTime);
          playBass(audioContext.currentTime, 65);
        }
      }, beatDuration * 2000);
      
      // Beat 4
      setTimeout(() => {
        if (musicState.playing) {
          playSnare(audioContext.currentTime);
          playHiHat(audioContext.currentTime);
        }
      }, beatDuration * 3000);
      
      // ç¹¼çºŒä¸‹ä¸€å€‹å¾ªç’°
      if (musicState.playing) {
        setTimeout(() => scheduleDrumPattern(), beatDuration * 4000);
      }
    }

    // é–‹å§‹éŸ³æ¨‚
    function startMusic() {
      if (musicState.playing) return;
      
      // æ¢å¾© AudioContextï¼ˆéœ€è¦ç”¨æˆ¶äº¤äº’ï¼‰
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      musicState.playing = true;
      scheduleDrumPattern();
      
      document.getElementById('musicStatus').textContent = 'åœæ­¢éŸ³æ¨‚';
      document.getElementById('btnMusic').classList.remove('btn-info');
      document.getElementById('btnMusic').classList.add('btn-secondary');
      
      console.log('ğŸµ èƒŒæ™¯éŸ³æ¨‚é–‹å§‹');
    }

    // åœæ­¢éŸ³æ¨‚
    function stopMusic() {
      musicState.playing = false;
      
      document.getElementById('musicStatus').textContent = 'é–‹å•ŸéŸ³æ¨‚';
      document.getElementById('btnMusic').classList.remove('btn-secondary');
      document.getElementById('btnMusic').classList.add('btn-info');
      
      console.log('ğŸ”‡ èƒŒæ™¯éŸ³æ¨‚åœæ­¢');
    }

    // åˆ‡æ›éŸ³æ¨‚
    function toggleMusic() {
      if (musicState.playing) {
        stopMusic();
      } else {
        startMusic();
      }
    }

    // æ›´æ–°éŸ³é‡
    function updateVolume(value) {
      musicState.volume = value / 100;
      musicState.masterGain.gain.value = musicState.volume;
      document.getElementById('volumeValue').textContent = value + '%';
    }

    // æ›´æ–° BPM
    function updateBPM(value) {
      musicState.bpm = parseInt(value);
      console.log(`ğŸµ BPM æ›´æ–°ç‚º: ${musicState.bpm}`);
    }

    // æ’­æ”¾æ“Šä¸­éŸ³æ•ˆ
    function playHitSound(type) {
      const time = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      if (type === 'perfect') {
        osc.frequency.value = 880;
        gain.gain.setValueAtTime(0.4, time);
      } else if (type === 'good') {
        osc.frequency.value = 660;
        gain.gain.setValueAtTime(0.3, time);
      } else {
        osc.frequency.value = 220;
        gain.gain.setValueAtTime(0.2, time);
      }
      
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
      
      osc.connect(gain);
      gain.connect(musicState.masterGain);
      
      osc.start(time);
      osc.stop(time + 0.1);
    }

    // ========== éŠæˆ²ç‹€æ…‹ ==========
    const gameState = {
      running: false,
      score: 0,
      combo: 0,
      perfectCount: 0,
      goodCount: 0,
      missCount: 0,
      notes: [],  // ä¸å†ä½¿ç”¨ï¼Œæ”¹ç‚ºå„è»Œé“ç¨ç«‹
      devices: new Map(),
      mqttClient: null,
      trackStats: Array(9).fill(null).map(() => ({
        score: 0,
        perfect: 0,
        good: 0,
        miss: 0,
        total: 0,
        combo: 0,  // è»Œé“ç¨ç«‹çš„ combo
        notes: [],  // æ¯å€‹è»Œé“æœ‰è‡ªå·±çš„éŸ³ç¬¦é™£åˆ—
        spawnTimer: null  // æ¯å€‹è»Œé“æœ‰è‡ªå·±çš„ç”Ÿæˆè¨ˆæ™‚å™¨
      })),
      lastTouchTime: new Map()
    };

    // ========== åˆå§‹åŒ– ==========
    function init() {
      createTracks();
      createDeviceIndicators();
      setupEventListeners();
      console.log('ğŸ® éŠæˆ²åˆå§‹åŒ–å®Œæˆ');
    }

    // å‰µå»º 9 å€‹è»Œé“
    function createTracks() {
      const tracksContainer = document.getElementById('tracks');
      tracksContainer.innerHTML = '';
      
      for (let i = 0; i < CONFIG.trackCount; i++) {
        const track = document.createElement('div');
        track.className = 'track';
        track.dataset.trackIndex = i;
        
        // å‰µå»ºè»Œé“åˆ†æ•¸é¡¯ç¤º
        const trackScore = document.createElement('div');
        trackScore.className = 'track-score';
        trackScore.id = `track-score-${i}`;
        trackScore.innerHTML = `
          <span class="score-num">0</span>
          <span class="accuracy">0%</span>
        `;
        track.appendChild(trackScore);
        
        // å‰µå»ºåˆ¤å®šå€
        const hitZone = document.createElement('div');
        hitZone.className = 'hit-zone';
        hitZone.textContent = i + 1;
        track.appendChild(hitZone);
        
        tracksContainer.appendChild(track);
      }
    }

    // å‰µå»ºè¨­å‚™ç‹€æ…‹æŒ‡ç¤ºå™¨
    function createDeviceIndicators() {
      const container = document.getElementById('deviceStatus');
      container.innerHTML = '';
      
      for (let i = 1; i <= CONFIG.trackCount; i++) {
        const indicator = document.createElement('div');
        indicator.className = 'device-indicator';
        indicator.id = `device-${i}`;
        indicator.textContent = i;
        container.appendChild(indicator);
      }
    }

    // ========== MQTT é€£ç·š ==========
    function connectMQTT() {
      const url = document.getElementById('mqttUrl').value.trim();
      
      if (!url) {
        alert('è«‹è¼¸å…¥ MQTT URL');
        return;
      }

      console.log(`é€£ç·šåˆ° ${url}...`);
      gameState.mqttClient = mqtt.connect(url);

      gameState.mqttClient.on('connect', () => {
        console.log('âœ“ MQTT é€£ç·šæˆåŠŸ');
        
        // è¨‚é–±æ¯å€‹ ESP32 è¨­å‚™çš„ç¨ç«‹ä¸»é¡Œ
        for (let i = 1; i <= CONFIG.trackCount; i++) {
          const deviceNum = String(i).padStart(2, '0');
          const topic = `esp32/device-${deviceNum}/touch`;
          
          gameState.mqttClient.subscribe(topic, (err) => {
            if (!err) {
              console.log(`ğŸ“¡ å·²è¨‚é–±: ${topic}`);
            }
          });
        }
        
        document.getElementById('btnStart').disabled = false;
      });

      gameState.mqttClient.on('message', (topic, payload) => {
        try {
          const data = JSON.parse(payload.toString());
          handleTouchEvent(data, topic);
        } catch (err) {
          console.error('è§£æ MQTT è¨Šæ¯éŒ¯èª¤:', err);
        }
      });

      gameState.mqttClient.on('error', (err) => {
        console.error('MQTT éŒ¯èª¤:', err);
      });
    }

    // è™•ç†è§¸æ‘¸äº‹ä»¶
    function handleTouchEvent(data, topic) {
      const { touch, device, timestamp } = data;
      
      // å¾ä¸»é¡Œæå–è¨­å‚™ç·¨è™Ÿ (esp32/device-01/touch -> 01 -> 1)
      const topicMatch = topic.match(/device-(\d+)/);
      if (!topicMatch) {
        console.warn('ç„¡æ³•è§£æä¸»é¡Œ:', topic);
        return;
      }
      
      const deviceNumber = parseInt(topicMatch[1]);
      const trackIndex = deviceNumber - 1;  // è¨­å‚™ 01 å°æ‡‰è»Œé“ 0
      
      if (trackIndex < 0 || trackIndex >= CONFIG.trackCount) return;
      
      // æ›´æ–°è¨­å‚™ç‹€æ…‹
      updateDeviceStatus(deviceNumber, touch === 1);
      
      // æ”¹æˆï¼šåªè¦è§¸ç™¼ï¼ˆtouch = 1ï¼‰å°±ç«‹å³æª¢æŸ¥æ‰“æ“Šï¼Œä¸éœ€è¦éŠæˆ²é‹è¡Œä¸­
      if (touch === 1) {
        // é˜²æŠ–è™•ç†ï¼šæª¢æŸ¥è·é›¢ä¸Šæ¬¡è§¸ç™¼çš„æ™‚é–“é–“éš”
        const now = Date.now();
        const lastTime = gameState.lastTouchTime.get(device) || 0;
        const debounceTime = 150;  // 150ms é˜²æŠ–æ™‚é–“
        
        if (now - lastTime < debounceTime) {
          console.log(`âš ï¸ ${device} è§¸ç™¼éå¿«ï¼Œå¿½ç•¥ (${now - lastTime}ms)`);
          return;
        }
        
        gameState.lastTouchTime.set(device, now);
        console.log(`âœ‹ è¨­å‚™ ${deviceNumber} è§¸ç™¼è»Œé“ ${trackIndex + 1}`);
        
        // å¦‚æœéŠæˆ²æ­£åœ¨é‹è¡Œï¼Œæª¢æŸ¥æ“Šä¸­
        if (gameState.running) {
          checkHit(trackIndex);
        } else {
          // éŠæˆ²æœªé‹è¡Œæ™‚ï¼Œåªé¡¯ç¤ºè§¸ç™¼æ•ˆæœ
          const track = document.querySelector(`.track[data-track-index="${trackIndex}"]`);
          const hitZone = track?.querySelector('.hit-zone');
          if (hitZone) {
            flashHitZone(hitZone, 'active');
            playHitSound('good');
          }
        }
      }
    }

    // æ›´æ–°è¨­å‚™ç‹€æ…‹æŒ‡ç¤ºå™¨
    function updateDeviceStatus(deviceNumber, isActive) {
      const indicator = document.getElementById(`device-${deviceNumber}`);
      if (!indicator) return;
      
      indicator.classList.add('connected');
      
      if (isActive) {
        indicator.classList.add('active');
        setTimeout(() => {
          indicator.classList.remove('active');
        }, 300);
      }
    }

    // ========== éŠæˆ²é‚è¼¯ ==========
    let gameLoop;

    function startGame() {
      gameState.running = true;
      gameState.score = 0;
      gameState.combo = 0;
      gameState.perfectCount = 0;
      gameState.goodCount = 0;
      gameState.missCount = 0;
      
      updateUI();
      
      // æ¸…é™¤æ‰€æœ‰è»Œé“çš„ç¾æœ‰éŸ³ç¬¦
      document.querySelectorAll('.note').forEach(note => note.remove());
      
      // ç‚ºæ¯å€‹è»Œé“å•Ÿå‹•ç¨ç«‹çš„éŸ³ç¬¦ç”Ÿæˆå™¨
      for (let i = 0; i < CONFIG.trackCount; i++) {
        gameState.trackStats[i].notes = [];
        startTrackNoteSpawner(i);
      }
      
      // é–‹å§‹éŠæˆ²å¾ªç’°
      gameLoop = requestAnimationFrame(update);
      
      document.getElementById('btnStart').disabled = true;
      document.getElementById('btnPause').disabled = false;
      
      console.log('ğŸ® éŠæˆ²é–‹å§‹ï¼9 äººæ¯”è³½æ¨¡å¼');
    }

    function pauseGame() {
      gameState.running = false;
      
      // åœæ­¢æ‰€æœ‰è»Œé“çš„ç”Ÿæˆå™¨
      for (let i = 0; i < CONFIG.trackCount; i++) {
        if (gameState.trackStats[i].spawnTimer) {
          clearInterval(gameState.trackStats[i].spawnTimer);
          gameState.trackStats[i].spawnTimer = null;
        }
      }
      
      cancelAnimationFrame(gameLoop);
      
      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnPause').disabled = true;
      
      console.log('â¸ï¸ éŠæˆ²æš«åœ');
    }

    function resetGame() {
      pauseGame();
      
      // æ¸…é™¤æ‰€æœ‰éŸ³ç¬¦
      document.querySelectorAll('.note').forEach(note => note.remove());
      
      gameState.score = 0;
      gameState.combo = 0;
      gameState.perfectCount = 0;
      gameState.goodCount = 0;
      gameState.missCount = 0;
      gameState.lastTouchTime.clear();
      
      // é‡ç½®æ‰€æœ‰è»Œé“çµ±è¨ˆ
      for (let i = 0; i < CONFIG.trackCount; i++) {
        gameState.trackStats[i] = {
          score: 0,
          perfect: 0,
          good: 0,
          miss: 0,
          total: 0,
          combo: 0,
          notes: [],
          spawnTimer: null
        };
        updateTrackScore(i);
      }
      
      updateUI();
      console.log('ğŸ”„ éŠæˆ²é‡ç½®');
    }

    // ç‚ºå–®ä¸€è»Œé“å•Ÿå‹•éŸ³ç¬¦ç”Ÿæˆå™¨
    function startTrackNoteSpawner(trackIndex) {
      // ç«‹å³ç”Ÿæˆç¬¬ä¸€å€‹éŸ³ç¬¦
      spawnNote(trackIndex);
      
      // è¨­å®šå®šæ™‚ç”Ÿæˆ
      gameState.trackStats[trackIndex].spawnTimer = setInterval(() => {
        if (gameState.running) {
          spawnNote(trackIndex);
        }
      }, CONFIG.spawnInterval);
    }

    // åœ¨æŒ‡å®šè»Œé“ç”ŸæˆéŸ³ç¬¦
    function spawnNote(trackIndex) {
      const track = document.querySelector(`.track[data-track-index="${trackIndex}"]`);
      if (!track) return;
      
      // éš¨æ©Ÿç”Ÿæˆé€Ÿåº¦ï¼ˆåœ¨æœ€å°å’Œæœ€å¤§é€Ÿåº¦ä¹‹é–“ï¼‰
      let noteSpeed;
      if (CONFIG.speedVariation) {
        noteSpeed = CONFIG.noteSpeedMin + Math.random() * (CONFIG.noteSpeedMax - CONFIG.noteSpeedMin);
      } else {
        noteSpeed = (CONFIG.noteSpeedMin + CONFIG.noteSpeedMax) / 2;  // ä½¿ç”¨å¹³å‡é€Ÿåº¦
      }
      
      const note = document.createElement('div');
      note.className = 'note';
      note.style.top = '-60px';
      note.textContent = trackIndex + 1;
      
      // æ ¹æ“šé€Ÿåº¦èª¿æ•´éŸ³ç¬¦é¡è‰²äº®åº¦ï¼ˆé€Ÿåº¦å¿«çš„æ›´äº®ï¼‰
      const speedRatio = (noteSpeed - CONFIG.noteSpeedMin) / (CONFIG.noteSpeedMax - CONFIG.noteSpeedMin);
      const brightness = 0.8 + speedRatio * 0.4;  // 0.8 åˆ° 1.2
      note.style.filter = `brightness(${brightness})`;
      
      const noteData = {
        element: note,
        trackIndex: trackIndex,
        y: -60,
        speed: noteSpeed,  // æ¯å€‹éŸ³ç¬¦æœ‰è‡ªå·±çš„é€Ÿåº¦
        hit: false
      };
      
      gameState.trackStats[trackIndex].notes.push(noteData);
      track.appendChild(note);
    }

    // éŠæˆ²æ›´æ–°å¾ªç’°
    function update() {
      if (!gameState.running) return;
      
      // æ›´æ–°æ‰€æœ‰è»Œé“çš„éŸ³ç¬¦
      for (let trackIndex = 0; trackIndex < CONFIG.trackCount; trackIndex++) {
        const trackNotes = gameState.trackStats[trackIndex].notes;
        
        for (let i = trackNotes.length - 1; i >= 0; i--) {
          const noteData = trackNotes[i];
          // ä½¿ç”¨æ¯å€‹éŸ³ç¬¦è‡ªå·±çš„é€Ÿåº¦
          noteData.y += noteData.speed;
          noteData.element.style.top = `${noteData.y}px`;
          
          // æª¢æŸ¥æ˜¯å¦è¶…å‡ºè¢å¹•ï¼ˆMISSï¼‰
          if (noteData.y > CONFIG.hitZoneY + 150 && !noteData.hit) {
            noteData.hit = true;
            handleMiss(noteData);
            removeNote(trackIndex, i);
          }
        }
      }
      
      gameLoop = requestAnimationFrame(update);
    }

    // æª¢æŸ¥æ“Šä¸­ï¼ˆé‡å°ç‰¹å®šè»Œé“ï¼‰
    function checkHit(trackIndex) {
      const track = document.querySelector(`.track[data-track-index="${trackIndex}"]`);
      const hitZone = track.querySelector('.hit-zone');
      
      // æ‰¾åˆ°è©²è»Œé“ä¸Šæœ€æ¥è¿‘åˆ¤å®šå€çš„éŸ³ç¬¦
      const trackNotes = gameState.trackStats[trackIndex].notes;
      let closestNote = null;
      let closestDistance = Infinity;
      let closestIndex = -1;
      
      // å°‹æ‰¾åœ¨åˆ¤å®šç¯„åœå…§ä¸”æœ€æ¥è¿‘åˆ¤å®šå€çš„éŸ³ç¬¦
      trackNotes.forEach((noteData, index) => {
        if (!noteData.hit) {
          const distance = Math.abs(noteData.y - CONFIG.hitZoneY);
          
          // åªè€ƒæ…®åœ¨åˆç†ç¯„åœå…§çš„éŸ³ç¬¦ï¼ˆGood ç¯„åœçš„ 1.5 å€ï¼‰
          if (distance < CONFIG.goodWindow * 1.5 && distance < closestDistance) {
            closestDistance = distance;
            closestNote = noteData;
            closestIndex = index;
          }
        }
      });
      
      if (!closestNote) {
        console.log(`ğŸ” è»Œé“ ${trackIndex + 1} æ²’æœ‰å¯æ“Šæ‰“çš„éŸ³ç¬¦`);
        // é¡¯ç¤ºè¦–è¦ºå›é¥‹
        flashHitZone(hitZone, 'active');
        return;
      }
      
      console.log(`ğŸ¯ è»Œé“ ${trackIndex + 1} è§¸ç™¼ - éŸ³ç¬¦ä½ç½®: ${closestNote.y.toFixed(0)}px, åˆ¤å®šå€: ${CONFIG.hitZoneY}px, è·é›¢: ${closestDistance.toFixed(0)}px`);
      
      // åˆ¤å®šï¼ˆå®Œå…¨ç¨ç«‹æ–¼å…¶ä»–è»Œé“ï¼‰
      if (closestDistance < CONFIG.perfectWindow) {
        console.log(`âœ¨ è»Œé“ ${trackIndex + 1} - PERFECT!`);
        handlePerfect(closestNote, hitZone);
        removeNote(trackIndex, closestIndex);
      } else if (closestDistance < CONFIG.goodWindow) {
        console.log(`ğŸ‘ è»Œé“ ${trackIndex + 1} - GOOD!`);
        handleGood(closestNote, hitZone);
        removeNote(trackIndex, closestIndex);
      } else {
        console.log(`âŒ è»Œé“ ${trackIndex + 1} - è·é›¢å¤ªé : ${closestDistance.toFixed(0)}px (éœ€è¦ < ${CONFIG.goodWindow}px)`);
        // é›–ç„¶æœ‰éŸ³ç¬¦ä½†è·é›¢å¤ªé ï¼Œé¡¯ç¤ºè¦–è¦ºå›é¥‹ä½†ä¸ç®— Miss
        flashHitZone(hitZone, 'active');
      }
    }

    // ç§»é™¤éŸ³ç¬¦ï¼ˆå¾ç‰¹å®šè»Œé“ï¼‰
    function removeNote(trackIndex, noteIndex) {
      const trackNotes = gameState.trackStats[trackIndex].notes;
      const noteData = trackNotes[noteIndex];
      
      if (noteData && noteData.element) {
        noteData.element.remove();
      }
      
      trackNotes.splice(noteIndex, 1);
    }

    // Perfect åˆ¤å®šï¼ˆè»Œé“ç¨ç«‹ï¼‰
    function handlePerfect(noteData, hitZone) {
      noteData.hit = true;
      const trackIndex = noteData.trackIndex;
      
      // å…¨å±€çµ±è¨ˆ
      gameState.score += 100;
      gameState.perfectCount++;
      
      // è»Œé“ç¨ç«‹çµ±è¨ˆ
      gameState.trackStats[trackIndex].combo++;
      gameState.trackStats[trackIndex].score += 100;
      gameState.trackStats[trackIndex].perfect++;
      gameState.trackStats[trackIndex].total++;
      
      showJudgment(`è»Œé“ ${trackIndex + 1} PERFECT`, 'perfect');
      flashHitZone(hitZone, 'perfect');
      playHitSound('perfect');
      updateUI();
      updateTrackScore(trackIndex);
      
      console.log(`âœ¨ è»Œé“ ${trackIndex + 1} - PERFECT! Combo: ${gameState.trackStats[trackIndex].combo}, åˆ†æ•¸: +100`);
    }

    // Good åˆ¤å®šï¼ˆè»Œé“ç¨ç«‹ï¼‰
    function handleGood(noteData, hitZone) {
      noteData.hit = true;
      const trackIndex = noteData.trackIndex;
      
      // å…¨å±€çµ±è¨ˆ
      gameState.score += 50;
      gameState.goodCount++;
      
      // è»Œé“ç¨ç«‹çµ±è¨ˆ
      gameState.trackStats[trackIndex].combo++;
      gameState.trackStats[trackIndex].score += 50;
      gameState.trackStats[trackIndex].good++;
      gameState.trackStats[trackIndex].total++;
      
      showJudgment(`è»Œé“ ${trackIndex + 1} GOOD`, 'good');
      flashHitZone(hitZone, 'good');
      playHitSound('good');
      updateUI();
      updateTrackScore(trackIndex);
      
      console.log(`ğŸ‘ è»Œé“ ${trackIndex + 1} - GOOD! Combo: ${gameState.trackStats[trackIndex].combo}, åˆ†æ•¸: +50`);
    }

    // Miss åˆ¤å®šï¼ˆè»Œé“ç¨ç«‹ï¼‰
    function handleMiss(noteData) {
      const trackIndex = noteData.trackIndex;
      
      // åªé‡ç½®è©²è»Œé“çš„ comboï¼Œä¸å½±éŸ¿å…¶ä»–è»Œé“
      gameState.trackStats[trackIndex].combo = 0;
      gameState.missCount++;
      
      // æ›´æ–°è»Œé“çµ±è¨ˆ
      gameState.trackStats[trackIndex].miss++;
      gameState.trackStats[trackIndex].total++;
      
      showJudgment(`è»Œé“ ${trackIndex + 1} MISS`, 'miss');
      playHitSound('miss');
      updateUI();
      updateTrackScore(trackIndex);
      
      console.log(`âŒ è»Œé“ ${trackIndex + 1} - MISS! è»Œé“ Combo é‡ç½®`);
    }

    // é¡¯ç¤ºåˆ¤å®šæ–‡å­—
    function showJudgment(text, type) {
      const existing = document.querySelector('.judgment');
      if (existing) existing.remove();
      
      const judgment = document.createElement('div');
      judgment.className = `judgment ${type}`;
      judgment.textContent = text;
      document.getElementById('gameArea').appendChild(judgment);
      
      setTimeout(() => judgment.remove(), 800);
    }

    // åˆ¤å®šå€é–ƒçˆæ•ˆæœ
    function flashHitZone(hitZone, type) {
      hitZone.classList.add(type);
      setTimeout(() => {
        hitZone.classList.remove(type);
      }, 200);
    }

    // æ›´æ–° UI
    function updateUI() {
      document.getElementById('score').textContent = gameState.score;
      document.getElementById('combo').textContent = gameState.combo;
      
      const total = gameState.perfectCount + gameState.goodCount + gameState.missCount;
      const accuracy = total > 0 
        ? Math.round(((gameState.perfectCount * 100 + gameState.goodCount * 50) / (total * 100)) * 100)
        : 100;
      document.getElementById('accuracy').textContent = accuracy + '%';
    }

    // æ›´æ–°è»Œé“åˆ†æ•¸é¡¯ç¤º
    function updateTrackScore(trackIndex) {
      const stats = gameState.trackStats[trackIndex];
      const scoreElement = document.getElementById(`track-score-${trackIndex}`);
      
      if (!scoreElement) return;
      
      const total = stats.total;
      const accuracy = total > 0 
        ? Math.round(((stats.perfect * 100 + stats.good * 50) / (total * 100)) * 100)
        : 0;
      
      scoreElement.innerHTML = `
        <span class="score-num">${stats.score}</span>
        <span class="accuracy">${accuracy}%</span>
      `;
      
      // æ ¹æ“šæº–ç¢ºåº¦æ”¹è®Šé¡è‰²
      const scoreNum = scoreElement.querySelector('.score-num');
      if (accuracy >= 90) {
        scoreNum.style.color = '#00ff00';
      } else if (accuracy >= 70) {
        scoreNum.style.color = '#ffd700';
      } else if (accuracy >= 50) {
        scoreNum.style.color = '#ff9900';
      } else {
        scoreNum.style.color = '#ff0000';
      }
    }

    // ========== äº‹ä»¶ç›£è½ ==========
    function setupEventListeners() {
      document.getElementById('btnConnect').addEventListener('click', connectMQTT);
      document.getElementById('btnStart').addEventListener('click', startGame);
      document.getElementById('btnPause').addEventListener('click', pauseGame);
      document.getElementById('btnReset').addEventListener('click', resetGame);
      document.getElementById('btnMusic').addEventListener('click', toggleMusic);
      
      // éŸ³é‡æ§åˆ¶
      document.getElementById('volumeSlider').addEventListener('input', (e) => {
        updateVolume(e.target.value);
      });
      
      // BPM æ§åˆ¶
      document.getElementById('bpmInput').addEventListener('change', (e) => {
        updateBPM(e.target.value);
      });
      
      // é€Ÿåº¦è®ŠåŒ–é–‹é—œ
      document.getElementById('speedVariation').addEventListener('change', (e) => {
        CONFIG.speedVariation = e.target.checked;
        console.log(`é€Ÿåº¦è®ŠåŒ–: ${CONFIG.speedVariation ? 'é–‹å•Ÿ' : 'é—œé–‰'}`);
      });
      
      // æœ€å°é€Ÿåº¦æ§åˆ¶
      document.getElementById('minSpeed').addEventListener('change', (e) => {
        const value = parseFloat(e.target.value);
        if (value < CONFIG.noteSpeedMax) {
          CONFIG.noteSpeedMin = value;
          console.log(`æœ€å°é€Ÿåº¦è¨­å®šç‚º: ${value}`);
        } else {
          alert('æœ€å°é€Ÿåº¦ä¸èƒ½å¤§æ–¼æˆ–ç­‰æ–¼æœ€å¤§é€Ÿåº¦ï¼');
          e.target.value = CONFIG.noteSpeedMin;
        }
      });
      
      // æœ€å¤§é€Ÿåº¦æ§åˆ¶
      document.getElementById('maxSpeed').addEventListener('change', (e) => {
        const value = parseFloat(e.target.value);
        if (value > CONFIG.noteSpeedMin) {
          CONFIG.noteSpeedMax = value;
          console.log(`æœ€å¤§é€Ÿåº¦è¨­å®šç‚º: ${value}`);
        } else {
          alert('æœ€å¤§é€Ÿåº¦ä¸èƒ½å°æ–¼æˆ–ç­‰æ–¼æœ€å°é€Ÿåº¦ï¼');
          e.target.value = CONFIG.noteSpeedMax;
        }
      });
      
      // éŸ³ç¬¦ç”Ÿæˆé–“éš”æ§åˆ¶
      document.getElementById('spawnInterval').addEventListener('change', (e) => {
        const value = parseInt(e.target.value);
        if (value >= 1000 && value <= 8000) {
          CONFIG.spawnInterval = value;
          console.log(`éŸ³ç¬¦ç”Ÿæˆé–“éš”è¨­å®šç‚º: ${value}ms`);
          
          // å¦‚æœéŠæˆ²æ­£åœ¨é‹è¡Œï¼Œé‡æ–°å•Ÿå‹•ç”Ÿæˆå™¨
          if (gameState.running) {
            console.log('âš ï¸ è«‹é‡æ–°é–‹å§‹éŠæˆ²ä»¥å¥—ç”¨æ–°çš„é–“éš”è¨­å®š');
          }
        } else {
          alert('é–“éš”å¿…é ˆåœ¨ 1000-8000ms ä¹‹é–“ï¼');
          e.target.value = CONFIG.spawnInterval;
        }
      });
      
      // éµç›¤æ¸¬è©¦ï¼ˆ1-9 éµï¼‰
      document.addEventListener('keydown', (e) => {
        if (!gameState.running) return;
        const key = parseInt(e.key);
        if (key >= 1 && key <= 9) {
          checkHit(key - 1);
        }
      });
    }

    // ========== å•Ÿå‹• ==========
    window.addEventListener('load', init);
  </script>
</body>
</html>
