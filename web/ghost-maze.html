<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸƒ è¬è–ç¯€é¬¼å±‹è¿·å®®</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #ff6b00;
      overflow: hidden;
      height: 100vh;
    }

    .container {
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding-right: 300px; /* ç‚ºå³å´ç‹€æ…‹é¢æ¿ç•™å‡ºç©ºé–“ */
    }

    .header {
      background: linear-gradient(180deg, #1a0a00, #0a0a0a);
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #ff6b00;
      box-shadow: 0 5px 20px rgba(255, 107, 0, 0.5);
    }

    .header h1 {
      font-size: 48px;
      text-shadow: 0 0 20px #ff6b00, 0 0 40px #ff3300;
      margin-bottom: 10px;
      animation: flicker 3s infinite;
    }

    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
      75% { opacity: 0.9; }
    }

    .subtitle {
      font-size: 18px;
      color: #ffaa00;
      opacity: 0.8;
    }

    .maze-container {
      flex: 1;
      position: relative;
      background: 
        radial-gradient(circle at 20% 30%, rgba(255, 107, 0, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(138, 43, 226, 0.05) 0%, transparent 50%),
        #0a0a0a;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .maze-grid {
      width: min(calc(100vh - 200px), calc(100vw - 400px)); /* æ­£æ–¹å½¢å°ºå¯¸ */
      height: min(calc(100vh - 200px), calc(100vw - 400px));
      max-width: 800px;
      max-height: 800px;
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(10, 1fr);
      gap: 2px;
      background: rgba(20, 10, 0, 0.5);
      border: 3px solid #ff6b00;
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 0 30px rgba(255, 107, 0, 0.3);
    }

    .maze-cell {
      background: rgba(50, 20, 0, 0.3);
      border: 1px solid rgba(255, 107, 0, 0.2);
      border-radius: 5px;
      position: relative;
      transition: all 0.3s;
    }

    .maze-cell.wall {
      background: rgba(100, 40, 0, 0.6);
      border-color: rgba(255, 107, 0, 0.4);
    }

    .maze-cell:hover {
      background: rgba(255, 107, 0, 0.1);
    }

    .ghost {
      position: fixed;
      width: 60px;
      height: 60px;
      font-size: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 50;
      cursor: pointer;
      filter: drop-shadow(0 0 10px currentColor);
      animation: float 3s ease-in-out infinite;
      opacity: 0;
      transform: scale(0);
      pointer-events: none; /* é¿å…é®æ“‹é»æ“Š */
    }

    .ghost.active {
      opacity: 1;
      transform: scale(1);
      animation: float 3s ease-in-out infinite, appear 0.5s ease-out;
    }

    .ghost.hidden {
      opacity: 0.2;
      transform: scale(0.5);
      filter: grayscale(100%) brightness(0.5);
    }

    @keyframes float {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-15px) scale(1.05); }
    }

    @keyframes appear {
      from {
        opacity: 0;
        transform: scale(0) rotate(360deg);
      }
      to {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
    }

    .ghost-label {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      background: rgba(0, 0, 0, 0.8);
      padding: 2px 8px;
      border-radius: 10px;
      white-space: nowrap;
      border: 1px solid currentColor;
    }

    .ghost-light-value {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      background: rgba(0, 0, 0, 0.9);
      padding: 2px 6px;
      border-radius: 8px;
      white-space: nowrap;
      opacity: 0.7;
    }

    .status-panel {
      position: fixed;
      top: 100px;
      right: 20px;
      width: 280px;
      background: rgba(0, 0, 0, 0.95);
      border: 2px solid #ff6b00;
      border-radius: 15px;
      padding: 20px;
      max-height: calc(100vh - 140px);
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(255, 107, 0, 0.5);
      z-index: 100;
    }

    .status-title {
      font-size: 20px;
      margin-bottom: 15px;
      text-align: center;
      color: #ffaa00;
    }

    .game-info {
      background: rgba(255, 107, 0, 0.2);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
      text-align: center;
      border: 2px solid #ff6b00;
    }

    .timer {
      font-size: 32px;
      font-weight: bold;
      color: #ffaa00;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #ff6b00;
    }

    .timer.warning {
      color: #ff0000;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .ghost-status {
      margin: 10px 0;
      padding: 10px;
      background: rgba(255, 107, 0, 0.1);
      border-radius: 8px;
      border-left: 3px solid #ff6b00;
    }

    .ghost-status.active {
      border-left-color: #00ff00;
      animation: glow 2s infinite;
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 0, 0.3); }
      50% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.6); }
    }

    .ghost-status-name {
      font-weight: bold;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .ghost-score {
      font-size: 16px;
      color: #ffaa00;
      font-weight: bold;
    }

    .ghost-status-info {
      font-size: 12px;
      opacity: 0.8;
    }

    .treasure {
      position: fixed;
      width: 40px;
      height: 40px;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 45;
      animation: treasure-glow 2s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes treasure-glow {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 5px gold);
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.2);
        filter: drop-shadow(0 0 20px gold);
      }
    }

    .collision-effect {
      position: fixed;
      font-size: 48px;
      z-index: 999;
      animation: collision-pop 1s ease-out forwards;
      pointer-events: none;
    }

    @keyframes collision-pop {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(0);
      }
      50% {
        transform: translate(-50%, -50%) scale(1.5);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5) translateY(-100px);
      }
    }

    .connection-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border-radius: 25px;
      border: 2px solid #ff6b00;
    }

    .connection-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f00;
      box-shadow: 0 0 10px currentColor;
      animation: blink 1s infinite;
    }

    .connection-dot.connected {
      background: #0f0;
      animation: none;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .music-control {
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 25px;
      border: 2px solid #ff6b00;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s;
      z-index: 1000;
    }

    .music-control:hover {
      background: rgba(255, 107, 0, 0.3);
      transform: scale(1.05);
    }

    .music-icon {
      font-size: 20px;
      animation: pulse-music 2s infinite;
    }

    .music-control.muted .music-icon {
      animation: none;
      opacity: 0.5;
    }

    @keyframes pulse-music {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .instructions {
      position: fixed;
      top: 120px;
      left: 20px;
      background: rgba(0, 0, 0, 0.95);
      border: 2px solid #ff6b00;
      border-radius: 15px;
      padding: 15px 20px;
      text-align: left;
      max-width: 280px;
      box-shadow: 0 0 20px rgba(255, 107, 0, 0.3);
      z-index: 90;
    }

    .instructions-title {
      font-size: 16px;
      margin-bottom: 10px;
      color: #ffaa00;
      font-weight: bold;
    }

    .instructions-text {
      font-size: 13px;
      line-height: 1.8;
      color: #fff;
    }

    .instructions-link {
      display: none; /* éš±è—æ‰‹æ©Ÿæ§åˆ¶å™¨æŒ‰éˆ• */
    }

    .youtube-player {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 320px;
      height: 180px;
      border: 3px solid #ff6b00;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(255, 107, 0, 0.5);
      z-index: 100;
      background: #000;
    }

    .youtube-player iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .youtube-toggle {
      position: fixed;
      bottom: 210px;
      left: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #ff6b00;
      border-radius: 10px;
      padding: 8px 15px;
      cursor: pointer;
      color: #ffaa00;
      font-size: 14px;
      transition: all 0.3s;
      z-index: 101;
    }

    .youtube-toggle:hover {
      background: rgba(255, 107, 0, 0.3);
      transform: scale(1.05);
    }

    .youtube-player.hidden {
      display: none;
    }

    /* æ»¾å‹•æ¢æ¨£å¼ */
    .status-panel::-webkit-scrollbar {
      width: 8px;
    }

    .status-panel::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
    }

    .status-panel::-webkit-scrollbar-thumb {
      background: #ff6b00;
      border-radius: 10px;
    }

    .status-panel::-webkit-scrollbar-thumb:hover {
      background: #ffaa00;
    }

    /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
    @media (max-width: 1400px) {
      .instructions {
        font-size: 12px;
        padding: 12px 15px;
        max-width: 250px;
      }

      .instructions-title {
        font-size: 14px;
      }

      .instructions-text {
        font-size: 12px;
      }
    }

    @media (max-width: 1200px) {
      .container {
        padding-right: 0;
      }

      .status-panel {
        width: 240px;
        padding: 15px;
        font-size: 14px;
      }

      .maze-grid {
        width: min(calc(100vh - 200px), calc(100vw - 300px));
        height: min(calc(100vh - 200px), calc(100vw - 300px));
      }

      .instructions {
        top: auto;
        bottom: 20px;
        left: 20px;
        max-width: 220px;
      }
    }

    @media (max-width: 768px) {
      .status-panel {
        top: auto;
        bottom: 20px;
        right: 20px;
        width: 200px;
        max-height: 40vh;
      }

      .instructions {
        display: none; /* å°è¢å¹•éš±è—èªªæ˜ */
      }

      .maze-grid {
        width: min(calc(100vh - 150px), calc(100vw - 40px));
        height: min(calc(100vh - 150px), calc(100vw - 40px));
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- æ¨™é¡Œ -->
    <div class="header">
      <h1>ğŸƒ è¬è–ç¯€é¬¼å±‹è¿·å®® ğŸ‘»</h1>
      <div class="subtitle">åœ°ä¸‹è¿·å®®æ¢éšª - ç”¨æ‰‹é›»ç­’å–šé†’ä½ çš„é¬¼é­‚</div>
    </div>

    <!-- è¿·å®®å€åŸŸ -->
    <div class="maze-container" id="mazeContainer">
      <div class="maze-grid" id="mazeGrid"></div>
    </div>

    <!-- é€£ç·šæŒ‡ç¤ºå™¨ -->
    <div class="connection-indicator">
      <div class="connection-dot" id="connectionDot"></div>
      <span id="connectionText">é€£æ¥ä¸­...</span>
    </div>

    <!-- éŸ³æ¨‚æ§åˆ¶ -->
    <div class="music-control" id="musicControl" title="é»æ“Šé–‹å•Ÿ/é—œé–‰éŸ³æ¨‚">
      <span class="music-icon">ğŸµ</span>
      <span id="musicText">é»æ“Šæ’­æ”¾</span>
    </div>

    <!-- ç‹€æ…‹é¢æ¿ -->
    <div class="status-panel">
      <div class="game-info">
        <div class="timer" id="timer">03:00</div>
        <div style="font-size: 14px; color: #fff;">â° å‰©é¤˜æ™‚é–“</div>
      </div>
      <div class="status-title">ğŸ‘» é¬¼é­‚ç‹€æ…‹</div>
      <div id="ghostStatusList"></div>
    </div>

    <!-- æ“ä½œèªªæ˜ -->
    <div class="instructions">
      <div class="instructions-title">ğŸ“± å¦‚ä½•æ“ä½œ</div>
      <div class="instructions-text">
        1. ç”¨æ‰‹é›»ç­’ç…§äº® ESP32 å…‰æ•é›»é˜»<br>
        2. æ‰‹æ©Ÿé–‹å•Ÿæ§åˆ¶å™¨ç¶²é <br>
        3. å…‰ç·šå……è¶³å¾Œè‡ªå‹•å•Ÿå‹•æ§åˆ¶<br>
        4. ä½¿ç”¨æ–¹å‘éµæ§åˆ¶é¬¼é­‚ç§»å‹•<br>
        5. æŒ‰ä¸‹ ğŸ’ æŒ‰éˆ•æŠ“å–å¯¶ç‰©<br>
        6. é¿å…ç¢°æ’ï¼Œæ¶å¥ªå¯¶ç‰©å¾—åˆ†
      </div>
    </div>

    <!-- YouTube éŸ³æ¨‚æ’­æ”¾å™¨åˆ‡æ›æŒ‰éˆ• -->
    <div class="youtube-toggle" id="youtubeToggle">
      ğŸµ é¡¯ç¤º/éš±è—éŸ³æ¨‚
    </div>

    <!-- YouTube éŸ³æ¨‚æ’­æ”¾å™¨ -->
    <div class="youtube-player" id="youtubePlayer">
      <iframe 
        src="https://www.youtube.com/embed/wTZZNpuZYTI?autoplay=1&loop=1&playlist=wTZZNpuZYTI&controls=1" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
        allowfullscreen>
      </iframe>
    </div>
  </div>

  <script src="https://unpkg.com/mqtt@5.3.5/dist/mqtt.min.js"></script>
  <script>
    // ========== è¨­å®š ==========
    const WS_URL = 'ws://192.168.100.200:8080';
    const GHOST_COUNT = 9;
    const MAZE_SIZE = 10;
    const CELL_SIZE = 60;
    const LIGHT_THRESHOLD = 3000;
    const GAME_DURATION = 180; // 3åˆ†é˜ = 180ç§’
    const COLLISION_PENALTY = -100; // ç¢°æ’æ‰£åˆ†
    const TREASURE_REWARD = 500; // å¯¶ç‰©åŠ åˆ†
    const MIN_TREASURES = 10;
    const MAX_TREASURES = 15;

    // é¬¼é­‚é¡è‰²
    const GHOST_COLORS = [
      '#ff6b00', '#ff00ff', '#00ffff', '#ffff00', 
      '#ff0099', '#00ff99', '#9900ff', '#ff9900', '#00ff00'
    ];

    // é¬¼é­‚è¡¨æƒ…ç¬¦è™Ÿ
    const GHOST_EMOJIS = ['ğŸ‘»', 'ğŸƒ', 'ğŸ¦‡', 'ğŸ’€', 'ğŸ•·ï¸', 'ğŸ•¸ï¸', 'ğŸ§›', 'ğŸ§Ÿ', 'ğŸ‘¹'];

    // ========== ç‹€æ…‹ ==========
    let ws = null;
    const ghosts = new Map();  // device-01 -> {x, y, light, active, element, score}
    const treasures = []; // [{x, y, element}]
    let gameTimer = GAME_DURATION;
    let gameInterval = null;
    let gameStarted = false;

    // ========== DOM å…ƒç´  ==========
    const mazeContainerEl = document.getElementById('mazeContainer');
    const mazeGridEl = document.getElementById('mazeGrid');
    const connectionDotEl = document.getElementById('connectionDot');
    const connectionTextEl = document.getElementById('connectionText');
    const ghostStatusListEl = document.getElementById('ghostStatusList');
    const timerEl = document.getElementById('timer');
    const musicControlEl = document.getElementById('musicControl');
    const musicTextEl = document.getElementById('musicText');
    const youtubePlayerEl = document.getElementById('youtubePlayer');
    const youtubeToggleEl = document.getElementById('youtubeToggle');
    
    let isMusicPlaying = false;
    let audioContext = null;
    let bgMusicOscillator = null;
    let isYoutubeVisible = true;

    // ========== åˆå§‹åŒ–è¿·å®® ==========
    function initMaze() {
      // å»ºç«‹ 10x10 æ ¼å­
      for (let row = 0; row < MAZE_SIZE; row++) {
        for (let col = 0; col < MAZE_SIZE; col++) {
          const cell = document.createElement('div');
          cell.className = 'maze-cell';
          cell.dataset.row = row;
          cell.dataset.col = col;
          
          // éš¨æ©ŸåŠ å…¥ç‰†å£ï¼ˆ20% æ©Ÿç‡ï¼‰
          if (Math.random() < 0.2) {
            cell.classList.add('wall');
          }
          
          mazeGridEl.appendChild(cell);
        }
      }
    }

    // ========== åˆå§‹åŒ–é¬¼é­‚ ==========
    function initGhosts() {
      for (let i = 1; i <= GHOST_COUNT; i++) {
        const deviceId = `esp32-device-${String(i).padStart(2, '0')}`;
        const ghost = {
          device: deviceId,
          x: Math.floor(Math.random() * MAZE_SIZE),
          y: Math.floor(Math.random() * MAZE_SIZE),
          light: 0,
          active: false,
          color: GHOST_COLORS[i - 1],
          emoji: GHOST_EMOJIS[i - 1],
          element: null,
          score: 0 // æ–°å¢åˆ†æ•¸
        };
        
        ghosts.set(deviceId, ghost);
        createGhostElement(ghost);
        createGhostStatus(ghost);
      }
    }

    // ========== åˆå§‹åŒ–å¯¶ç‰© ==========
    function initTreasures() {
      const treasureCount = Math.floor(Math.random() * (MAX_TREASURES - MIN_TREASURES + 1)) + MIN_TREASURES;
      const usedPositions = new Set();
      
      // è¨˜éŒ„é¬¼é­‚åˆå§‹ä½ç½®ï¼Œé¿å…é‡ç–Š
      ghosts.forEach(ghost => {
        usedPositions.add(`${ghost.x},${ghost.y}`);
      });
      
      for (let i = 0; i < treasureCount; i++) {
        let x, y, posKey;
        let attempts = 0;
        
        // å°‹æ‰¾ä¸é‡ç–Šçš„ä½ç½®
        do {
          x = Math.floor(Math.random() * MAZE_SIZE);
          y = Math.floor(Math.random() * MAZE_SIZE);
          posKey = `${x},${y}`;
          attempts++;
        } while (usedPositions.has(posKey) && attempts < 100);
        
        if (attempts < 100) {
          usedPositions.add(posKey);
          
          const treasure = { x, y, element: null };
          createTreasureElement(treasure);
          treasures.push(treasure);
        }
      }
      
      console.log(`ğŸ’ ç”Ÿæˆäº† ${treasures.length} å€‹å¯¶ç‰©`);
    }

    // ========== å»ºç«‹å¯¶ç‰©å…ƒç´  ==========
    function createTreasureElement(treasure) {
      const treasureEl = document.createElement('div');
      treasureEl.className = 'treasure';
      treasureEl.innerHTML = 'ğŸ’';
      treasureEl.style.position = 'fixed';
      treasureEl.style.zIndex = '45';
      
      treasure.element = treasureEl;
      document.body.appendChild(treasureEl);
      
      updateTreasurePosition(treasure);
    }

    // ========== æ›´æ–°å¯¶ç‰©ä½ç½® ==========
    function updateTreasurePosition(treasure) {
      const gridRect = mazeGridEl.getBoundingClientRect();
      const cellWidth = gridRect.width / MAZE_SIZE;
      const cellHeight = gridRect.height / MAZE_SIZE;
      
      const x = gridRect.left + (treasure.x + 0.5) * cellWidth;
      const y = gridRect.top + (treasure.y + 0.5) * cellHeight;
      
      treasure.element.style.left = `${x}px`;
      treasure.element.style.top = `${y}px`;
      treasure.element.style.transform = `translate(-50%, -50%)`;
    }

    // ========== å»ºç«‹é¬¼é­‚å…ƒç´  ==========
    function createGhostElement(ghost) {
      const ghostEl = document.createElement('div');
      ghostEl.className = 'ghost hidden';
      ghostEl.innerHTML = ghost.emoji;
      ghostEl.style.color = ghost.color;
      ghostEl.style.position = 'fixed'; // ä½¿ç”¨ fixed å®šä½
      ghostEl.style.zIndex = '50';
      
      // æ¨™ç±¤
      const label = document.createElement('div');
      label.className = 'ghost-label';
      label.textContent = ghost.device.split('-')[2];
      label.style.color = ghost.color;
      ghostEl.appendChild(label);
      
      // å…‰ç·šæ•¸å€¼
      const lightValue = document.createElement('div');
      lightValue.className = 'ghost-light-value';
      lightValue.textContent = 'ğŸ’¡ 0';
      ghostEl.appendChild(lightValue);
      
      ghost.element = ghostEl;
      document.body.appendChild(ghostEl); // é™„åŠ åˆ° body
      
      updateGhostPosition(ghost);
    }

    // ========== æ›´æ–°é¬¼é­‚ä½ç½® ==========
    function updateGhostPosition(ghost) {
      const gridRect = mazeGridEl.getBoundingClientRect();
      
      // è¨ˆç®—æ¯å€‹æ ¼å­çš„å¯¦éš›å°ºå¯¸
      const cellWidth = gridRect.width / MAZE_SIZE;
      const cellHeight = gridRect.height / MAZE_SIZE;
      
      // è¨ˆç®—é¬¼é­‚çš„çµ•å°ä½ç½®ï¼ˆç›¸å°æ–¼è¦–çª—ï¼‰
      const x = gridRect.left + (ghost.x + 0.5) * cellWidth;
      const y = gridRect.top + (ghost.y + 0.5) * cellHeight;
      
      // è¨­å®šé¬¼é­‚ä½ç½®ï¼ˆfixed å®šä½ï¼‰
      ghost.element.style.position = 'fixed';
      ghost.element.style.left = `${x}px`;
      ghost.element.style.top = `${y}px`;
      ghost.element.style.transform = `translate(-50%, -50%)`;
    }

    // ========== å»ºç«‹é¬¼é­‚ç‹€æ…‹é¡¯ç¤º ==========
    function createGhostStatus(ghost) {
      const statusEl = document.createElement('div');
      statusEl.className = 'ghost-status';
      statusEl.id = `status-${ghost.device}`;
      statusEl.innerHTML = `
        <div class="ghost-status-name" style="color: ${ghost.color};">
          <span>${ghost.emoji} ${ghost.device.split('-')[2]}</span>
          <span class="ghost-score" id="score-${ghost.device}">0åˆ†</span>
        </div>
        <div class="ghost-status-info">
          ğŸ’¡ å…‰ç·š: <span id="light-${ghost.device}">0</span><br>
          ğŸ“ ä½ç½®: (<span id="pos-${ghost.device}">0, 0</span>)<br>
          âš¡ ç‹€æ…‹: <span id="active-${ghost.device}">éš±è—</span>
        </div>
      `;
      ghostStatusListEl.appendChild(statusEl);
    }

    // ========== æ›´æ–°åˆ†æ•¸ ==========
    function updateScore(deviceId, points, reason) {
      const ghost = ghosts.get(deviceId);
      if (!ghost) return;
      
      ghost.score += points;
      
      // æ›´æ–°é¡¯ç¤º
      const scoreEl = document.getElementById(`score-${deviceId}`);
      if (scoreEl) {
        scoreEl.textContent = `${ghost.score}åˆ†`;
      }
      
      console.log(`ğŸ’° ${deviceId} ${reason}: ${points > 0 ? '+' : ''}${points}åˆ†ï¼ˆç¸½åˆ†: ${ghost.score}ï¼‰`);
    }

    // ========== æ›´æ–°é¬¼é­‚ç‹€æ…‹ ==========
    function updateGhostStatus(deviceId, data) {
      const ghost = ghosts.get(deviceId);
      if (!ghost) return;

      if (data.light !== undefined) {
        ghost.light = data.light;
        ghost.active = data.active;
        
        // æ›´æ–°è¦–è¦º
        if (ghost.active) {
          ghost.element.classList.remove('hidden');
          ghost.element.classList.add('active');
        } else {
          ghost.element.classList.add('hidden');
          ghost.element.classList.remove('active');
        }
        
        // æ›´æ–°å…‰ç·šæ•¸å€¼é¡¯ç¤º
        const lightValueEl = ghost.element.querySelector('.ghost-light-value');
        lightValueEl.textContent = `ğŸ’¡ ${ghost.light}`;
        
        // æ›´æ–°ç‹€æ…‹é¢æ¿
        const statusEl = document.getElementById(`status-${deviceId}`);
        if (statusEl) {
          if (ghost.active) {
            statusEl.classList.add('active');
          } else {
            statusEl.classList.remove('active');
          }
          
          document.getElementById(`light-${deviceId}`).textContent = ghost.light;
          document.getElementById(`pos-${deviceId}`).textContent = `${ghost.x}, ${ghost.y}`;
          document.getElementById(`active-${deviceId}`).textContent = ghost.active ? 'âœ… é¡¯ç¤º' : 'âŒ éš±è—';
        }
      }
    }

    // ========== ç§»å‹•é¬¼é­‚ ==========
    function moveGhost(deviceId, direction) {
      const ghost = ghosts.get(deviceId);
      if (!ghost || !ghost.active) {
        console.log(`âŒ ${deviceId} ç„¡æ³•ç§»å‹•ï¼ˆæœªæ¿€æ´»æˆ–ä¸å­˜åœ¨ï¼‰`);
        return;
      }

      const oldX = ghost.x;
      const oldY = ghost.y;

      // è¨ˆç®—æ–°ä½ç½®
      switch (direction) {
        case 'up':
          ghost.y = Math.max(0, ghost.y - 1);
          break;
        case 'down':
          ghost.y = Math.min(MAZE_SIZE - 1, ghost.y + 1);
          break;
        case 'left':
          ghost.x = Math.max(0, ghost.x - 1);
          break;
        case 'right':
          ghost.x = Math.min(MAZE_SIZE - 1, ghost.x + 1);
          break;
      }

      // æª¢æŸ¥æ˜¯å¦ç¢°åˆ°ç‰†å£
      const cell = document.querySelector(`[data-row="${ghost.y}"][data-col="${ghost.x}"]`);
      if (cell && cell.classList.contains('wall')) {
        // æ’ç‰†ï¼Œæ¢å¾©ä½ç½®
        ghost.x = oldX;
        ghost.y = oldY;
        console.log(`ğŸ§± ${deviceId} æ’ç‰†äº†ï¼`);
        return;
      }

      console.log(`ğŸ® ${deviceId} ç§»å‹•åˆ° (${ghost.x}, ${ghost.y})`);
      updateGhostPosition(ghost);
      
      // æ›´æ–°ç‹€æ…‹é¢æ¿
      document.getElementById(`pos-${deviceId}`).textContent = `${ghost.x}, ${ghost.y}`;
      
      // æª¢æŸ¥ç¢°æ’
      checkCollisions(deviceId);
    }

    // ========== æª¢æŸ¥ç¢°æ’ ==========
    function checkCollisions(movedGhostId) {
      const movedGhost = ghosts.get(movedGhostId);
      if (!movedGhost || !movedGhost.active) return;

      // æª¢æŸ¥èˆ‡å…¶ä»–é¬¼é­‚çš„ç¢°æ’
      ghosts.forEach((otherGhost, otherId) => {
        if (otherId !== movedGhostId && 
            otherGhost.active && 
            otherGhost.x === movedGhost.x && 
            otherGhost.y === movedGhost.y) {
          
          // å…©å€‹é¬¼é­‚éƒ½æ˜¯é¡¯ç¤ºç‹€æ…‹ï¼Œç™¼ç”Ÿç¢°æ’
          console.log(`ğŸ’¥ ç¢°æ’ï¼${movedGhostId} èˆ‡ ${otherId}`);
          
          // å…©å€‹éƒ½æ‰£åˆ†
          updateScore(movedGhostId, COLLISION_PENALTY, 'é¬¼é­‚ç¢°æ’');
          updateScore(otherId, COLLISION_PENALTY, 'é¬¼é­‚ç¢°æ’');
          
          // é¡¯ç¤ºç¢°æ’æ•ˆæœ
          showCollisionEffect(movedGhost);
        }
      });
    }

    // ========== é¡¯ç¤ºç¢°æ’æ•ˆæœ ==========
    function showCollisionEffect(ghost) {
      const effectEl = document.createElement('div');
      effectEl.className = 'collision-effect';
      effectEl.innerHTML = 'ğŸ’¥';
      effectEl.style.color = '#ff0000';
      
      const gridRect = mazeGridEl.getBoundingClientRect();
      const cellWidth = gridRect.width / MAZE_SIZE;
      const cellHeight = gridRect.height / MAZE_SIZE;
      
      const x = gridRect.left + (ghost.x + 0.5) * cellWidth;
      const y = gridRect.top + (ghost.y + 0.5) * cellHeight;
      
      effectEl.style.position = 'fixed';
      effectEl.style.left = `${x}px`;
      effectEl.style.top = `${y}px`;
      
      document.body.appendChild(effectEl);
      
      // 1ç§’å¾Œç§»é™¤
      setTimeout(() => {
        effectEl.remove();
      }, 1000);
    }

    // ========== æŠ“å–å¯¶ç‰© ==========
    function grabTreasure(deviceId) {
      const ghost = ghosts.get(deviceId);
      if (!ghost || !ghost.active) {
        console.log(`âŒ ${deviceId} ç„¡æ³•æŠ“å–å¯¶ç‰©ï¼ˆæœªæ¿€æ´»ï¼‰`);
        return;
      }

      // æŸ¥æ‰¾ç•¶å‰ä½ç½®æ˜¯å¦æœ‰å¯¶ç‰©
      const treasureIndex = treasures.findIndex(t => 
        t.x === ghost.x && t.y === ghost.y
      );

      if (treasureIndex !== -1) {
        // æ‰¾åˆ°å¯¶ç‰©ï¼
        const treasure = treasures[treasureIndex];
        
        console.log(`ğŸ‰ ${deviceId} æŠ“åˆ°å¯¶ç‰©ï¼ä½ç½®: (${treasure.x}, ${treasure.y})`);
        
        // åŠ åˆ†
        updateScore(deviceId, TREASURE_REWARD, 'æŠ“å–å¯¶ç‰©');
        
        // ç§»é™¤å¯¶ç‰©
        treasure.element.remove();
        treasures.splice(treasureIndex, 1);
        
        // é¡¯ç¤ºå¯¶ç‰©ç²å¾—æ•ˆæœ
        showTreasureEffect(ghost);
      } else {
        console.log(`âŒ ${deviceId} é€™è£¡æ²’æœ‰å¯¶ç‰©`);
      }
    }

    // ========== é¡¯ç¤ºå¯¶ç‰©ç²å¾—æ•ˆæœ ==========
    function showTreasureEffect(ghost) {
      const effectEl = document.createElement('div');
      effectEl.className = 'collision-effect';
      effectEl.innerHTML = `+${TREASURE_REWARD}ğŸ’`;
      effectEl.style.color = '#ffd700';
      
      const gridRect = mazeGridEl.getBoundingClientRect();
      const cellWidth = gridRect.width / MAZE_SIZE;
      const cellHeight = gridRect.height / MAZE_SIZE;
      
      const x = gridRect.left + (ghost.x + 0.5) * cellWidth;
      const y = gridRect.top + (ghost.y + 0.5) * cellHeight;
      
      effectEl.style.position = 'fixed';
      effectEl.style.left = `${x}px`;
      effectEl.style.top = `${y}px`;
      
      document.body.appendChild(effectEl);
      
      setTimeout(() => {
        effectEl.remove();
      }, 1000);
    }

    // ========== WebSocket é€£æ¥ ==========
    function connectWebSocket() {
      ws = new WebSocket(WS_URL);
      
      ws.onopen = () => {
        console.log('âœ… WebSocket é€£æ¥æˆåŠŸ');
        connectionDotEl.classList.add('connected');
        connectionTextEl.textContent = 'å·²é€£æ¥';
        
        // è¨‚é–±æ‰€æœ‰è£ç½®çš„å…‰ç·šæ•¸æ“šå’Œç§»å‹•æŒ‡ä»¤
        for (let i = 1; i <= GHOST_COUNT; i++) {
          const deviceId = `esp32-device-${String(i).padStart(2, '0')}`;
          
          // è¨‚é–±å…‰ç·šæ•¸æ“š
          ws.send(JSON.stringify({
            type: 'subscribe',
            topic: `esp32/${deviceId}/light`
          }));
          
          // è¨‚é–±ç§»å‹•æŒ‡ä»¤
          ws.send(JSON.stringify({
            type: 'subscribe',
            topic: `ghost/move/${deviceId}`
          }));
          
          // è¨‚é–±æŠ“å–å¯¶ç‰©æŒ‡ä»¤
          ws.send(JSON.stringify({
            type: 'subscribe',
            topic: `ghost/grab/${deviceId}`
          }));
        }
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleMessage(data);
        } catch (e) {
          console.error('è§£æè¨Šæ¯å¤±æ•—:', e);
        }
      };
      
      ws.onerror = (error) => {
        console.error('âŒ WebSocket éŒ¯èª¤:', error);
        connectionTextEl.textContent = 'é€£æ¥éŒ¯èª¤';
      };
      
      ws.onclose = () => {
        console.log('ğŸ”Œ WebSocket å·²æ–·é–‹ï¼Œ3 ç§’å¾Œé‡é€£...');
        connectionDotEl.classList.remove('connected');
        connectionTextEl.textContent = 'å·²æ–·é–‹';
        setTimeout(connectWebSocket, 3000);
      };
    }

    // ========== è™•ç†è¨Šæ¯ ==========
    function handleMessage(data) {
      if (!data.topic) return;

      if (data.topic.includes('/light')) {
        // å…‰ç·šæ•¸æ“š
        const payload = JSON.parse(data.payload);
        const deviceId = payload.device;
        updateGhostStatus(deviceId, payload);
        
        // ç¬¬ä¸€æ¬¡æœ‰é¬¼é­‚æ¿€æ´»æ™‚é–‹å§‹éŠæˆ²
        if (!gameStarted && payload.active) {
          startGame();
        }
      } else if (data.topic.includes('ghost/move/')) {
        // ç§»å‹•æŒ‡ä»¤
        const payload = JSON.parse(data.payload);
        const deviceId = payload.device;
        const direction = payload.direction;
        moveGhost(deviceId, direction);
      } else if (data.topic.includes('ghost/grab/')) {
        // æŠ“å–å¯¶ç‰©æŒ‡ä»¤
        const payload = JSON.parse(data.payload);
        const deviceId = payload.device;
        grabTreasure(deviceId);
      }
    }

    // ========== é–‹å§‹éŠæˆ² ==========
    function startGame() {
      if (gameStarted) return;
      
      gameStarted = true;
      console.log('ğŸ® éŠæˆ²é–‹å§‹ï¼');
      
      // é–‹å§‹å€’è¨ˆæ™‚
      gameInterval = setInterval(() => {
        gameTimer--;
        updateTimer();
        
        if (gameTimer <= 0) {
          endGame();
        }
      }, 1000);
    }

    // ========== æ›´æ–°è¨ˆæ™‚å™¨ ==========
    function updateTimer() {
      const minutes = Math.floor(gameTimer / 60);
      const seconds = gameTimer % 60;
      const timeStr = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      
      timerEl.textContent = timeStr;
      
      // æœ€å¾Œ30ç§’è®Šç´…è‰²è­¦å‘Š
      if (gameTimer <= 30) {
        timerEl.classList.add('warning');
      }
    }

    // ========== çµæŸéŠæˆ² ==========
    function endGame() {
      clearInterval(gameInterval);
      gameStarted = false;
      
      console.log('â° éŠæˆ²çµæŸï¼');
      
      // è¨ˆç®—æœ€çµ‚æ’å
      const rankings = Array.from(ghosts.values())
        .sort((a, b) => b.score - a.score)
        .map((ghost, index) => `${index + 1}. ${ghost.device.split('-')[2]} - ${ghost.score}åˆ†`)
        .join('\n');
      
      alert(`ğŸ éŠæˆ²çµæŸï¼\n\næœ€çµ‚æ’åï¼š\n${rankings}`);
      
      // å¯é¸ï¼šé‡æ–°é–‹å§‹éŠæˆ²
      if (confirm('æ˜¯å¦é‡æ–°é–‹å§‹éŠæˆ²ï¼Ÿ')) {
        location.reload();
      }
    }

    // ========== è¦–çª—å¤§å°æ”¹è®Šæ™‚æ›´æ–°ä½ç½® ==========
    window.addEventListener('resize', () => {
      ghosts.forEach(ghost => {
        updateGhostPosition(ghost);
      });
      treasures.forEach(treasure => {
        updateTreasurePosition(treasure);
      });
    });

    // ========== éŸ³æ¨‚æ§åˆ¶ ==========
    // ä½¿ç”¨ Web Audio API ç”Ÿæˆè±å¯Œçš„è¬è–ç¯€æ°›åœéŸ³æ•ˆ
    function createSpookyAmbience() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }

      const nodes = [];

      // 1. ä½é »ä¸å®‰æ„ŸåŸºåº•ï¼ˆæ·±æ²‰çš„ç„¡èª¿éŸ³ï¼‰
      const bass1 = audioContext.createOscillator();
      const bass2 = audioContext.createOscillator();
      const bassGain = audioContext.createGain();
      
      bass1.type = 'sine';
      bass1.frequency.setValueAtTime(55, audioContext.currentTime); // A1
      bass2.type = 'sine';
      bass2.frequency.setValueAtTime(58.27, audioContext.currentTime); // A#1 (ä¸å”å’ŒéŸ³ç¨‹)
      
      bassGain.gain.setValueAtTime(0.08, audioContext.currentTime);
      
      bass1.connect(bassGain);
      bass2.connect(bassGain);
      bassGain.connect(audioContext.destination);
      
      nodes.push({ osc: bass1 }, { osc: bass2 });

      // 2. ä¸­é »è©­ç•°éŸ³æ•ˆï¼ˆæ¨¡æ“¬é¢¨è²ï¼‰
      const wind = audioContext.createOscillator();
      const windGain = audioContext.createGain();
      const windFilter = audioContext.createBiquadFilter();
      
      wind.type = 'sawtooth';
      wind.frequency.setValueAtTime(220, audioContext.currentTime);
      
      windFilter.type = 'lowpass';
      windFilter.frequency.setValueAtTime(400, audioContext.currentTime);
      windFilter.Q.setValueAtTime(5, audioContext.currentTime);
      
      windGain.gain.setValueAtTime(0.03, audioContext.currentTime);
      
      // é¢¨è²çš„é¡«å‹•æ•ˆæœ
      const windLFO = audioContext.createOscillator();
      const windLFOGain = audioContext.createGain();
      windLFO.frequency.setValueAtTime(0.3, audioContext.currentTime);
      windLFOGain.gain.setValueAtTime(100, audioContext.currentTime);
      
      windLFO.connect(windLFOGain);
      windLFOGain.connect(wind.frequency);
      
      wind.connect(windFilter);
      windFilter.connect(windGain);
      windGain.connect(audioContext.destination);
      
      nodes.push({ osc: wind }, { osc: windLFO });

      // 3. é«˜é »è©­ç•°éŸ³æ•ˆï¼ˆåƒæ˜¯é è™•çš„å°–å«ï¼‰
      const eerie = audioContext.createOscillator();
      const eerieGain = audioContext.createGain();
      const eerieFilter = audioContext.createBiquadFilter();
      
      eerie.type = 'triangle';
      eerie.frequency.setValueAtTime(880, audioContext.currentTime);
      
      eerieFilter.type = 'bandpass';
      eerieFilter.frequency.setValueAtTime(1200, audioContext.currentTime);
      eerieFilter.Q.setValueAtTime(10, audioContext.currentTime);
      
      eerieGain.gain.setValueAtTime(0.02, audioContext.currentTime);
      
      // é«˜é »çš„æ…¢é€Ÿé¡«å‹•
      const eerieLFO = audioContext.createOscillator();
      const eerieLFOGain = audioContext.createGain();
      eerieLFO.frequency.setValueAtTime(0.2, audioContext.currentTime);
      eerieLFOGain.gain.setValueAtTime(200, audioContext.currentTime);
      
      eerieLFO.connect(eerieLFOGain);
      eerieLFOGain.connect(eerie.frequency);
      
      eerie.connect(eerieFilter);
      eerieFilter.connect(eerieGain);
      eerieGain.connect(audioContext.destination);
      
      nodes.push({ osc: eerie }, { osc: eerieLFO });

      // 4. ä½é »è„ˆè¡ï¼ˆå¿ƒè·³æ„Ÿï¼‰
      const pulse = audioContext.createOscillator();
      const pulseGain = audioContext.createGain();
      
      pulse.type = 'sine';
      pulse.frequency.setValueAtTime(110, audioContext.currentTime);
      
      pulseGain.gain.setValueAtTime(0, audioContext.currentTime);
      
      // å‰µå»ºå¿ƒè·³ç¯€å¥
      const now = audioContext.currentTime;
      for (let i = 0; i < 100; i++) {
        const time = now + i * 2; // æ¯2ç§’ä¸€æ¬¡
        pulseGain.gain.setValueAtTime(0, time);
        pulseGain.gain.linearRampToValueAtTime(0.15, time + 0.1);
        pulseGain.gain.linearRampToValueAtTime(0, time + 0.3);
        pulseGain.gain.setValueAtTime(0, time + 0.4);
        pulseGain.gain.linearRampToValueAtTime(0.12, time + 0.5);
        pulseGain.gain.linearRampToValueAtTime(0, time + 0.7);
      }
      
      pulse.connect(pulseGain);
      pulseGain.connect(audioContext.destination);
      
      nodes.push({ osc: pulse });

      // 5. ç™½å™ªéŸ³ï¼ˆåƒæ˜¯è€èˆŠæ”¶éŸ³æ©Ÿçš„é›œè¨Šï¼‰
      const bufferSize = 2 * audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      
      const whiteNoise = audioContext.createBufferSource();
      whiteNoise.buffer = noiseBuffer;
      whiteNoise.loop = true;
      
      const noiseFilter = audioContext.createBiquadFilter();
      noiseFilter.type = 'lowpass';
      noiseFilter.frequency.setValueAtTime(200, audioContext.currentTime);
      
      const noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(0.01, audioContext.currentTime);
      
      whiteNoise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(audioContext.destination);
      
      nodes.push({ osc: whiteNoise });

      // å•Ÿå‹•æ‰€æœ‰éŸ³æ•ˆ
      nodes.forEach(node => node.osc.start());
      
      console.log('ğŸƒ è¬è–ç¯€éŸ³æ•ˆå±¤æ¬¡ï¼šä½éŸ³åŸºåº• + é¢¨è² + è©­ç•°é«˜éŸ³ + å¿ƒè·³ + ç™½å™ªéŸ³');
      
      return nodes;
    }

    function stopSpookyAmbience() {
      if (bgMusicOscillator) {
        try {
          bgMusicOscillator.forEach(node => {
            try {
              node.osc.stop();
            } catch (e) {
              // å·²ç¶“åœæ­¢
            }
          });
        } catch (e) {
          console.log('éŸ³æ¨‚å·²åœæ­¢');
        }
        bgMusicOscillator = null;
      }
    }

    musicControlEl.addEventListener('click', () => {
      if (isMusicPlaying) {
        stopSpookyAmbience();
        musicControlEl.classList.add('muted');
        musicTextEl.textContent = 'å·²éœéŸ³';
        isMusicPlaying = false;
        console.log('ğŸ”‡ éŸ³æ¨‚å·²æš«åœ');
      } else {
        try {
          bgMusicOscillator = createSpookyAmbience();
          musicControlEl.classList.remove('muted');
          musicTextEl.textContent = 'æ’­æ”¾ä¸­';
          isMusicPlaying = true;
          console.log('ï¿½ è¬è–ç¯€æ°›åœéŸ³æ•ˆæ’­æ”¾ä¸­');
        } catch (err) {
          console.error('âŒ éŸ³æ¨‚æ’­æ”¾å¤±æ•—:', err);
          musicTextEl.textContent = 'æ’­æ”¾å¤±æ•—';
          alert('éŸ³æ¨‚æ’­æ”¾å¤±æ•—: ' + err.message);
        }
      }
    });
    
    // YouTube æ’­æ”¾å™¨é¡¯ç¤º/éš±è—åˆ‡æ›
    youtubeToggleEl.addEventListener('click', () => {
      isYoutubeVisible = !isYoutubeVisible;
      if (isYoutubeVisible) {
        youtubePlayerEl.classList.remove('hidden');
      } else {
        youtubePlayerEl.classList.add('hidden');
      }
    });
    
    console.log('ğŸµ éŸ³æ¨‚ç³»çµ±å·²åˆå§‹åŒ–ï¼ˆWeb Audio API + YouTubeï¼‰ï¼Œè«‹é»æ“Šå³ä¸Šè§’æŒ‰éˆ•æ’­æ”¾');

    // ========== å•Ÿå‹• ==========
    initMaze();
    initGhosts();
    initTreasures();
    connectWebSocket();
  </script>
</body>
</html>
